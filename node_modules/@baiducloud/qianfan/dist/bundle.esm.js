import * as process$1 from 'process';
import { EventEmitter } from 'events';
import { URL as URL$1 } from 'url';
import require$$1 from 'tty';
import * as util from 'util';
import util__default from 'util';
import require$$0 from 'os';
import Mutex from 'await-mutex';
import require$$0$1 from 'fs';
import require$$1$1 from 'path';
import * as require$$3 from 'crypto';
import require$$3__default from 'crypto';
import Bottleneck from 'bottleneck';

function _AsyncGenerator(e) {
  var r, t;
  function resume(r, t) {
    try {
      var n = e[r](t),
        o = n.value,
        u = o instanceof _OverloadYield;
      Promise.resolve(u ? o.v : o).then(function (t) {
        if (u) {
          var i = "return" === r ? "return" : "next";
          if (!o.k || t.done) return resume(i, t);
          t = e[i](t).value;
        }
        settle(n.done ? "return" : "normal", t);
      }, function (e) {
        resume("throw", e);
      });
    } catch (e) {
      settle("throw", e);
    }
  }
  function settle(e, n) {
    switch (e) {
      case "return":
        r.resolve({
          value: n,
          done: !0
        });
        break;
      case "throw":
        r.reject(n);
        break;
      default:
        r.resolve({
          value: n,
          done: !1
        });
    }
    (r = r.next) ? resume(r.key, r.arg) : t = null;
  }
  this._invoke = function (e, n) {
    return new Promise(function (o, u) {
      var i = {
        key: e,
        arg: n,
        resolve: o,
        reject: u,
        next: null
      };
      t ? t = t.next = i : (r = t = i, resume(e, n));
    });
  }, "function" != typeof e.return && (this.return = void 0);
}
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
}, _AsyncGenerator.prototype.next = function (e) {
  return this._invoke("next", e);
}, _AsyncGenerator.prototype.throw = function (e) {
  return this._invoke("throw", e);
}, _AsyncGenerator.prototype.return = function (e) {
  return this._invoke("return", e);
};
function _OverloadYield(t, e) {
  this.v = t, this.k = e;
}
function _asyncIterator(r) {
  var n,
    t,
    o,
    e = 2;
  for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {
    if (t && null != (n = r[t])) return n.call(r);
    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));
    t = "@@asyncIterator", o = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(r) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var n = r.done;
    return Promise.resolve(r.value).then(function (r) {
      return {
        value: r,
        done: n
      };
    });
  }
  return AsyncFromSyncIterator = function (r) {
    this.s = r, this.n = r.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (r) {
      var n = this.s.return;
      return void 0 === n ? Promise.resolve({
        value: r,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
    },
    throw: function (r) {
      var n = this.s.return;
      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(r);
}
function _awaitAsyncGenerator(e) {
  return new _OverloadYield(e, 0);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

// Current version.
var VERSION = '1.13.6';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global.global === global && global || Function('return this')() || {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype,
  ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
  slice = ArrayProto.slice,
  toString = ObjProto.toString,
  hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
  supportsDataView = typeof DataView !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
  nativeKeys = Object.keys,
  nativeCreate = Object.create,
  nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
  _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{
  toString: null
}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function () {
    var length = Math.max(arguments.length - startIndex, 0),
      rest = Array(length),
      index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest);
      case 1:
        return func.call(this, arguments[0], rest);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}

// Is a given variable an object?
function isObject(obj) {
  var type = _typeof(obj);
  return type === 'function' || type === 'object' && !!obj;
}

// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}

// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}

// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
}

// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  var tag = '[object ' + name + ']';
  return function (obj) {
    return toString.call(obj) === tag;
  };
}

var isString = tagTester('String');

var isNumber = tagTester('Number');

var isDate = tagTester('Date');

var isRegExp = tagTester('RegExp');

var isError = tagTester('Error');

var isSymbol = tagTester('Symbol');

var isArrayBuffer = tagTester('ArrayBuffer');

var isFunction = tagTester('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != 'function' && (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {
  isFunction = function isFunction(obj) {
    return typeof obj == 'function' || false;
  };
}
var isFunction$1 = isFunction;

var hasObjectTag = tagTester('Object');

// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
// In IE 11, the most common among them, this problem also applies to
// `Map`, `WeakMap` and `Set`.
var hasStringTagBug = supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))),
  isIE11 = typeof Map !== 'undefined' && hasObjectTag(new Map());

var isDataView = tagTester('DataView');

// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
  return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
}
var isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;

// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
var isArray = nativeIsArray || tagTester('Array');

// Internal function to check whether `key` is an own property name of `obj`.
function has$1(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}

var isArguments = tagTester('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function () {
  if (!isArguments(arguments)) {
    isArguments = function isArguments(obj) {
      return has$1(obj, 'callee');
    };
  }
})();
var isArguments$1 = isArguments;

// Is a given object a finite number?
function isFinite$1(obj) {
  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}

// Is the given value `NaN`?
function isNaN$1(obj) {
  return isNumber(obj) && _isNaN(obj);
}

// Predicate-generating function. Often useful outside of Underscore.
function constant(value) {
  return function () {
    return value;
  };
}

// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function (collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}

// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function (obj) {
    return obj == null ? void 0 : obj[key];
  };
}

// Internal helper to obtain the `byteLength` property of an object.
var getByteLength = shallowProperty('byteLength');

// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
var isBufferLike = createSizePropertyCheck(getByteLength);

// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
}
var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);

// Internal helper to obtain the `length` property of an object.
var getLength = shallowProperty('length');

// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function contains(key) {
      return hash[key] === true;
    },
    push: function push(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;

  // Constructor is a special case.
  var prop = 'constructor';
  if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}

// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys(obj) {
  if (!isObject(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys = [];
  for (var key in obj) if (has$1(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
}

// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  var length = getLength(obj);
  if (typeof length == 'number' && (isArray(obj) || isString(obj) || isArguments$1(obj))) return length === 0;
  return getLength(keys(obj)) === 0;
}

// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = keys(attrs),
    length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _$1(obj) {
  if (obj instanceof _$1) return obj;
  if (!(this instanceof _$1)) return new _$1(obj);
  this._wrapped = obj;
}
_$1.VERSION = VERSION;

// Extracts the result from a wrapped and chained object.
_$1.prototype.value = function () {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
_$1.prototype.toString = function () {
  return String(this._wrapped);
};

// Internal function to wrap or shallow-copy an ArrayBuffer,
// typed array or DataView to a new view, reusing the buffer.
function toBufferView(bufferSource) {
  return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, getByteLength(bufferSource));
}

// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';

// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = _typeof(a);
  if (type !== 'function' && type !== 'object' && _typeof(b) != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _$1) a = a._wrapped;
  if (b instanceof _$1) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  // Work around a bug in IE 10 - Edge 13.
  if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {
    if (!isDataView$1(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case '[object ArrayBuffer]':
    case tagDataView:
      // Coerce to typed array so we can fall through.
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === '[object Array]';
  if (!areArrays && isTypedArray$1(a)) {
    var byteLength = getByteLength(a);
    if (byteLength !== getByteLength(b)) return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (_typeof(a) != 'object' || _typeof(b) != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor,
      bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = keys(a),
      key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}

// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
}

// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
function ie11fingerprint(methods) {
  var length = getLength(methods);
  return function (obj) {
    if (obj == null) return false;
    // `Map`, `WeakMap` and `Set` have no enumerable keys.
    var keys = allKeys(obj);
    if (getLength(keys)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction$1(obj[methods[i]])) return false;
    }
    // If we are testing against `WeakMap`, we need to ensure that
    // `obj` doesn't have a `forEach` method in order to distinguish
    // it from a regular `Map`.
    return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
  };
}

// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach',
  hasName = 'has',
  commonInit = ['clear', 'delete'],
  mapTail = ['get', hasName, 'set'];

// `Map`, `WeakMap` and `Set` each have slightly different
// combinations of the above sublists.
var mapMethods = commonInit.concat(forEachName, mapTail),
  weakMapMethods = commonInit.concat(mapTail),
  setMethods = ['add'].concat(commonInit, forEachName, hasName);

var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

var isWeakSet = tagTester('WeakSet');

// Retrieve the values of an object's properties.
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}

// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}

// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}

// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction$1(obj[key])) names.push(key);
  }
  return names.sort();
}

// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function (obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
        keys = keysFunc(source),
        l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}

// Extend a given object with all the properties in passed-in object(s).
var extend = createAssigner(allKeys);

// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
var extendOwn = createAssigner(keys);

// Fill in a given object with default properties.
var defaults = createAssigner(allKeys, true);

// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function () {};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor();
  Ctor.prototype = null;
  return result;
}

// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = baseCreate(prototype);
  if (props) extendOwn(result, props);
  return result;
}

// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}

// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

// Normalize a (deep) property `path` to array.
// Like `_.iteratee`, this function can be customized.
function toPath$1(path) {
  return isArray(path) ? path : [path];
}
_$1.toPath = toPath$1;

// Internal wrapper for `_.toPath` to enable minification.
// Similar to `cb` for `_.iteratee`.
function toPath(path) {
  return _$1.toPath(path);
}

// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}

// Get the value of the (deep) property on `path` from `object`.
// If any property in `path` does not exist or if the value is
// `undefined`, return `defaultValue` instead.
// The `path` is normalized through `_.toPath`.
function get(object, path, defaultValue) {
  var value = deepGet(object, toPath(path));
  return isUndefined(value) ? defaultValue : value;
}

// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has(obj, path) {
  path = toPath(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has$1(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}

// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}

// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function (obj) {
    return isMatch(obj, attrs);
  };
}

// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  path = toPath(path);
  return function (obj) {
    return deepGet(obj, path);
  };
}

// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function (value) {
        return func.call(context, value);
      };
    // The 2-argument case is omitted because we’re not using it.
    case 3:
      return function (value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function (accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function () {
    return func.apply(context, arguments);
  };
}

// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction$1(value)) return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray(value)) return matcher(value);
  return property(value);
}

// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_$1.iteratee = iteratee;

// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = keys(obj),
    length = _keys.length,
    results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

// Predicate-generating function. Often useful outside of Underscore.
function noop() {}

// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) return noop;
  return function (path) {
    return get(obj, path);
  };
}

// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = optimizeCb(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}

// Return a random integer between `min` and `max` (inclusive).
function random(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}

// A (possibly faster) way to get the current timestamp as an integer.
var now = Date.now || function () {
  return new Date().getTime();
};

// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function escaper(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + keys(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function (string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

// Internal list of HTML entities for escaping.
var escapeMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
};

// Function for escaping strings to HTML interpolation.
var escape = createEscaper(escapeMap);

// Internal list of HTML entities for unescaping.
var unescapeMap = invert(escapeMap);

// Function for unescaping strings from HTML interpolation.
var unescape = createEscaper(unescapeMap);

// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
var templateSettings = _$1.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};

// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  "\u2028": 'u2028',
  "\u2029": 'u2029'
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
  return '\\' + escapes[match];
}

// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults({}, settings, _$1.templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;
    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    // Insure against third-party code injection. (CVE-2021-23358)
    if (!bareIdentifier.test(argument)) throw new Error('variable is not a bare identifier: ' + argument);
  } else {
    // If a variable is not specified, place data values in local scope.
    source = 'with(obj||{}){\n' + source + '}\n';
    argument = 'obj';
  }
  source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
  var render;
  try {
    render = new Function(argument, '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template = function template(data) {
    return render.call(this, data, _$1);
  };

  // Provide the compiled source as a convenience for precompilation.
  template.source = 'function(' + argument + '){\n' + source + '}';
  return template;
}

// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result(obj, path, fallback) {
  path = toPath(path);
  var length = path.length;
  if (!length) {
    return isFunction$1(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = isFunction$1(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}

// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = _$1(obj);
  instance._chain = true;
  return instance;
}

// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = baseCreate(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if (isObject(result)) return result;
  return self;
}

// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = restArguments(function (func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function bound() {
    var position = 0,
      length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _$1;

// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
var bind = restArguments(function (func, context, args) {
  if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');
  var bound = restArguments(function (callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
});

// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
var isArrayLike = createSizePropertyCheck(getLength);

// Internal implementation of a recursive `flatten` function.
function flatten$1(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten$1(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0,
          len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
var bindAll = restArguments(function (obj, keys) {
  keys = flatten$1(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = bind(obj[key], obj);
  }
  return obj;
});

// Memoize an expensive function by storing its results.
function memoize(func, hasher) {
  var memoize = function memoize(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}

// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
var delay = restArguments(function (func, wait, args) {
  return setTimeout(function () {
    return func.apply(null, args);
  }, wait);
});

// Defers a function, scheduling it to run after the current call stack has
// cleared.
var defer = partial(delay, _$1, 1);

// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};
  var later = function later() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  var throttled = function throttled() {
    var _now = now();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function () {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}

// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;
  var later = function later() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };
  var debounced = restArguments(function (_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });
  debounced.cancel = function () {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}

// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return partial(wrapper, func);
}

// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function () {
    return !predicate.apply(this, arguments);
  };
}

// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function () {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}

// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function () {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}

// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function () {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}

// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
var once = partial(before, 2);

// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj),
    key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}

// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function (array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}

// Returns the first index on an array-like that passes a truth test.
var findIndex = createPredicateIndexFinder(1);

// Returns the last index on an array-like that passes a truth test.
var findLastIndex = createPredicateIndexFinder(-1);

// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex(array, obj, iteratee, context) {
  iteratee = cb(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0,
    high = getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
  }
  return low;
}

// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function (array, item, idx) {
    var i = 0,
      length = getLength(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN$1);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}

// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
var indexOf = createIndexFinder(1, findIndex, sortedIndex);

// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
var lastIndexOf = createIndexFinder(-1, findLastIndex);

// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}

// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}

// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}

// Return the results of applying the iteratee to each element.
function map(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = !isArrayLike(obj) && keys(obj),
    length = (_keys || obj).length,
    results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function reducer(obj, iteratee, memo, initial) {
    var _keys = !isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length,
      index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function (obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
  };
}

// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
var reduce = createReduce(1);

// The right-associative version of reduce, also known as `foldr`.
var reduceRight = createReduce(-1);

// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function (value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}

// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj),
    length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}

// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj),
    length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}

// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike(obj)) obj = values(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}

// Invoke a method (with arguments) on every item in a collection.
var invoke = restArguments(function (obj, path, args) {
  var contextPath, func;
  if (isFunction$1(path)) {
    func = path;
  } else {
    path = toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map(obj, function (context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});

// Convenience version of a common use case of `_.map`: fetching a property.
function pluck(obj, key) {
  return map(obj, property(key));
}

// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}

// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity,
    lastComputed = -Infinity,
    value,
    computed;
  if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function (v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity,
    lastComputed = Infinity,
    value,
    computed;
  if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function (v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || computed === Infinity && result === Infinity) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (isArray(obj)) return slice.call(obj);
  if (isString(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if (isArrayLike(obj)) return map(obj, identity);
  return values(obj);
}

// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample = toArray(obj);
  var length = getLength(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}

// Shuffle a collection.
function shuffle(obj) {
  return sample(obj, Infinity);
}

// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = cb(iteratee, context);
  return pluck(map(obj, function (value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function (left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}

// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function (obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = cb(iteratee, context);
    each(obj, function (value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}

// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
var groupBy = group(function (result, value, key) {
  if (has$1(result, key)) result[key].push(value);else result[key] = [value];
});

// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
var indexBy = group(function (result, value, key) {
  result[key] = value;
});

// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
var countBy = group(function (result, value, key) {
  if (has$1(result, key)) result[key]++;else result[key] = 1;
});

// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
var partition$1 = group(function (result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true);

// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike(obj) ? obj.length : keys(obj).length;
}

// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}

// Return a copy of the object only containing the allowed properties.
var pick = restArguments(function (obj, keys) {
  var result = {},
    iteratee = keys[0];
  if (obj == null) return result;
  if (isFunction$1(iteratee)) {
    if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
    keys = allKeys(obj);
  } else {
    iteratee = keyInObj;
    keys = flatten$1(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
});

// Return a copy of the object without the disallowed properties.
var omit = restArguments(function (obj, keys) {
  var iteratee = keys[0],
    context;
  if (isFunction$1(iteratee)) {
    iteratee = negate(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = map(flatten$1(keys, false, false), String);
    iteratee = function iteratee(value, key) {
      return !contains(keys, key);
    };
  }
  return pick(obj, iteratee, context);
});

// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}

// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}

// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}

// Trim out all falsy values from an array.
function compact(array) {
  return filter(array, Boolean);
}

// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten(array, depth) {
  return flatten$1(array, depth, false);
}

// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
var difference = restArguments(function (array, rest) {
  rest = flatten$1(rest, true, true);
  return filter(array, function (value) {
    return !contains(rest, value);
  });
});

// Return a version of the array that does not contain the specified value(s).
var without = restArguments(function (array, otherArrays) {
  return difference(array, otherArrays);
});

// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = cb(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = getLength(array); i < length; i++) {
    var value = array[i],
      computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!contains(result, value)) {
      result.push(value);
    }
  }
  return result;
}

// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
var union = restArguments(function (arrays) {
  return uniq(flatten$1(arrays, true, true));
});

// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength(array); i < length; i++) {
    var item = array[i];
    if (contains(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}

// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = array && max(array, getLength).length || 0;
  var result = Array(length);
  for (var index = 0; index < length; index++) {
    result[index] = pluck(array, index);
  }
  return result;
}

// Zip together multiple lists into a single array -- elements that share
// an index go together.
var zip = restArguments(unzip);

// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object(list, values) {
  var result = {};
  for (var i = 0, length = getLength(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}

// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }
  return range;
}

// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0,
    length = array.length;
  while (i < length) {
    result.push(slice.call(array, i, i += count));
  }
  return result;
}

// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? _$1(obj).chain() : obj;
}

// Add your own custom functions to the Underscore object.
function mixin(obj) {
  each(functions(obj), function (name) {
    var func = _$1[name] = obj[name];
    _$1.prototype[name] = function () {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_$1, args));
    };
  });
  return _$1;
}

// Add all mutator `Array` functions to the wrapper.
each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
  var method = ArrayProto[name];
  _$1.prototype[name] = function () {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
each(['concat', 'join', 'slice'], function (name) {
  var method = ArrayProto[name];
  _$1.prototype[name] = function () {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});

// Named Exports
// =============

var allExports = /*#__PURE__*/Object.freeze({
  __proto__: null,
  VERSION: VERSION,
  after: after,
  all: every,
  allKeys: allKeys,
  any: some,
  assign: extendOwn,
  before: before,
  bind: bind,
  bindAll: bindAll,
  chain: chain,
  chunk: chunk,
  clone: clone,
  collect: map,
  compact: compact,
  compose: compose,
  constant: constant,
  contains: contains,
  countBy: countBy,
  create: create,
  debounce: debounce,
  default: _$1,
  defaults: defaults,
  defer: defer,
  delay: delay,
  detect: find,
  difference: difference,
  drop: rest,
  each: each,
  escape: escape,
  every: every,
  extend: extend,
  extendOwn: extendOwn,
  filter: filter,
  find: find,
  findIndex: findIndex,
  findKey: findKey,
  findLastIndex: findLastIndex,
  findWhere: findWhere,
  first: first,
  flatten: flatten,
  foldl: reduce,
  foldr: reduceRight,
  forEach: each,
  functions: functions,
  get: get,
  groupBy: groupBy,
  has: has,
  head: first,
  identity: identity,
  include: contains,
  includes: contains,
  indexBy: indexBy,
  indexOf: indexOf,
  initial: initial,
  inject: reduce,
  intersection: intersection,
  invert: invert,
  invoke: invoke,
  isArguments: isArguments$1,
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBoolean: isBoolean,
  isDataView: isDataView$1,
  isDate: isDate,
  isElement: isElement,
  isEmpty: isEmpty,
  isEqual: isEqual,
  isError: isError,
  isFinite: isFinite$1,
  isFunction: isFunction$1,
  isMap: isMap,
  isMatch: isMatch,
  isNaN: isNaN$1,
  isNull: isNull,
  isNumber: isNumber,
  isObject: isObject,
  isRegExp: isRegExp,
  isSet: isSet,
  isString: isString,
  isSymbol: isSymbol,
  isTypedArray: isTypedArray$1,
  isUndefined: isUndefined,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet,
  iteratee: iteratee,
  keys: keys,
  last: last,
  lastIndexOf: lastIndexOf,
  map: map,
  mapObject: mapObject,
  matcher: matcher,
  matches: matcher,
  max: max,
  memoize: memoize,
  methods: functions,
  min: min,
  mixin: mixin,
  negate: negate,
  noop: noop,
  now: now,
  object: object,
  omit: omit,
  once: once,
  pairs: pairs,
  partial: partial,
  partition: partition$1,
  pick: pick,
  pluck: pluck,
  property: property,
  propertyOf: propertyOf,
  random: random,
  range: range,
  reduce: reduce,
  reduceRight: reduceRight,
  reject: reject,
  rest: rest,
  restArguments: restArguments,
  result: result,
  sample: sample,
  select: filter,
  shuffle: shuffle,
  size: size,
  some: some,
  sortBy: sortBy,
  sortedIndex: sortedIndex,
  tail: rest,
  take: first,
  tap: tap,
  template: template,
  templateSettings: templateSettings,
  throttle: throttle,
  times: times,
  toArray: toArray,
  toPath: toPath$1,
  transpose: unzip,
  unescape: unescape,
  union: union,
  uniq: uniq,
  unique: uniq,
  uniqueId: uniqueId,
  unzip: unzip,
  values: values,
  where: where,
  without: without,
  wrap: wrap,
  zip: zip
});

// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```

// Add all of the Underscore functions to the wrapper object.
var _ = mixin(allExports);
// Legacy Node.js API.
_._ = _;

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var src = {exports: {}};

var browser$1 = {exports: {}};

var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms = function ms(val, options) {
    options = options || {};
    var type = _typeof(val);
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
  return ms;
}

var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    /**
    * Active `debug` instances.
    */

    createDebug.instances = [];
    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];
    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */

    createDebug.formatters = {};
    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */

    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */

    function createDebug(namespace) {
      var prevTime;
      function debug() {
        // Disabled?
        if (!debug.enabled) {
          return;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var self = debug; // Set `diff` timestamp

        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        } // Apply any `formatters` transformations

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return match;
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }
          return match;
        }); // Apply env-specific formatting (colors, etc.)

        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend; // Debug.formatArgs = formatArgs;
      // debug.rawLog = rawLog;
      // env-specific initialization logic for debug instances

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    }
    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    /**
    * Disable debug output.
    *
    * @api public
    */

    function disable() {
      createDebug.enable('');
    }
    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      var i;
      var len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}

var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$1.exports;
  hasRequiredBrowser = 1;
  (function (module, exports) {

    function _typeof$1(obj) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        _typeof$1 = function _typeof$1(obj) {
          return _typeof(obj);
        };
      } else {
        _typeof$1 = function _typeof$1(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };
      }
      return _typeof$1(obj);
    }

    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    // eslint-disable-next-line complexity

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      } // Internet Explorer and Edge do not support colors.

      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      } // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632

      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      var _console;

      // This hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return (typeof console === "undefined" ? "undefined" : _typeof$1(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.getItem('debug');
      } catch (error) {} // Swallow
      // XXX (@Qix-) should we be logging these?
      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG

      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    module.exports = requireCommon()(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = function hasFlag(flag) {
    var argv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.argv;
    var prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    var position = argv.indexOf(prefix + flag);
    var terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  var os = require$$0;
  var tty = require$$1;
  var hasFlag = requireHasFlag();
  var _process = process,
    env = _process.env;
  var forceColor;
  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
  }
  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level: level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }
    if (hasFlag('color=256')) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    var min = forceColor || 0;
    if (env.TERM === 'dumb') {
      return min;
    }
    if (process.platform === 'win32') {
      // Windows 10 build 10586 is the first Windows release that supports 256 colors.
      // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
      var osRelease = os.release().split('.');
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ('CI' in env) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(function (sign) {
        return sign in env;
      }) || env.CI_NAME === 'codeship') {
        return 1;
      }
      return min;
    }
    if ('TEAMCITY_VERSION' in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
      return 3;
    }
    if ('TERM_PROGRAM' in env) {
      var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;
        case 'Apple_Terminal':
          return 2;
        // No default
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ('COLORTERM' in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    var level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}

var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function (module, exports) {

    /**
     * Module dependencies.
     */
    var tty = require$$1;
    var util = util__default;
    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      var supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
      }
    } catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
      return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
      // Camel-case
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
        return k.toUpperCase();
      }); // Coerce string value into JS value

      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === 'null') {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var name = this.namespace,
        useColors = this.useColors;
      if (useColors) {
        var c = this.color;
        var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
        var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }
      return new Date().toISOString() + ' ';
    }
    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log() {
      return process.stderr.write(util.format.apply(util, arguments) + '\n');
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }
    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
        return str.trim();
      }).join(' ');
    };
    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */
if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
var createDebug = /*@__PURE__*/getDefaultExportFromCjs(srcExports);

var version$3 = "0.0.7";

var main$1 = {exports: {}};

var name = "dotenv";
var version$2 = "16.4.1";
var description = "Loads environment variables from .env file";
var main = "lib/main.js";
var types = "lib/main.d.ts";
var exports = {
	".": {
		types: "./lib/main.d.ts",
		require: "./lib/main.js",
		"default": "./lib/main.js"
	},
	"./config": "./config.js",
	"./config.js": "./config.js",
	"./lib/env-options": "./lib/env-options.js",
	"./lib/env-options.js": "./lib/env-options.js",
	"./lib/cli-options": "./lib/cli-options.js",
	"./lib/cli-options.js": "./lib/cli-options.js",
	"./package.json": "./package.json"
};
var scripts = {
	"dts-check": "tsc --project tests/types/tsconfig.json",
	lint: "standard",
	"lint-readme": "standard-markdown",
	pretest: "npm run lint && npm run dts-check",
	test: "tap tests/*.js --100 -Rspec",
	prerelease: "npm test",
	release: "standard-version"
};
var repository = {
	type: "git",
	url: "git://github.com/motdotla/dotenv.git"
};
var funding = "https://github.com/motdotla/dotenv?sponsor=1";
var keywords = [
	"dotenv",
	"env",
	".env",
	"environment",
	"variables",
	"config",
	"settings"
];
var readmeFilename = "README.md";
var license = "BSD-2-Clause";
var devDependencies = {
	"@definitelytyped/dtslint": "^0.0.133",
	"@types/node": "^18.11.3",
	decache: "^4.6.1",
	sinon: "^14.0.1",
	standard: "^17.0.0",
	"standard-markdown": "^7.1.0",
	"standard-version": "^9.5.0",
	tap: "^16.3.0",
	tar: "^6.1.11",
	typescript: "^4.8.4"
};
var engines = {
	node: ">=12"
};
var browser = {
	fs: false
};
var require$$4 = {
	name: name,
	version: version$2,
	description: description,
	main: main,
	types: types,
	exports: exports,
	scripts: scripts,
	repository: repository,
	funding: funding,
	keywords: keywords,
	readmeFilename: readmeFilename,
	license: license,
	devDependencies: devDependencies,
	engines: engines,
	browser: browser
};

var fs = require$$0$1;
var path = require$$1$1;
var os = require$$0;
var crypto = require$$3__default;
var packageJson = require$$4;
var version$1 = packageJson.version;
var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;

// Parse src into an Object
function parse(src) {
  var obj = {};

  // Convert buffer to string
  var lines = src.toString();

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n');
  var match;
  while ((match = LINE.exec(lines)) != null) {
    var key = match[1];

    // Default undefined or null to empty string
    var value = match[2] || '';

    // Remove whitespace
    value = value.trim();

    // Check if double quoted
    var maybeQuote = value[0];

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n');
      value = value.replace(/\\r/g, '\r');
    }

    // Add to object
    obj[key] = value;
  }
  return obj;
}
function _parseVault(options) {
  var vaultPath = _vaultPath(options);

  // Parse .env.vault
  var result = DotenvModule.configDotenv({
    path: vaultPath
  });
  if (!result.parsed) {
    var err = new Error("MISSING_DATA: Cannot parse ".concat(vaultPath, " for an unknown reason"));
    err.code = 'MISSING_DATA';
    throw err;
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenv.org/vault/.env.vault?environment=prod"
  var keys = _dotenvKey(options).split(',');
  var length = keys.length;
  var decrypted;
  for (var i = 0; i < length; i++) {
    try {
      // Get full key
      var key = keys[i].trim();

      // Get instructions for decrypt
      var attrs = _instructions(result, key);

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error;
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted);
}
function _log(message) {
  console.log("[dotenv@".concat(version$1, "][INFO] ").concat(message));
}
function _warn(message) {
  console.log("[dotenv@".concat(version$1, "][WARN] ").concat(message));
}
function _debug(message) {
  console.log("[dotenv@".concat(version$1, "][DEBUG] ").concat(message));
}
function _dotenvKey(options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY;
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }

  // fallback to empty string
  return '';
}
function _instructions(result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  var uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      var err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development');
      err.code = 'INVALID_DOTENV_KEY';
      throw err;
    }
    throw error;
  }

  // Get decrypt key
  var key = uri.password;
  if (!key) {
    var _err = new Error('INVALID_DOTENV_KEY: Missing key part');
    _err.code = 'INVALID_DOTENV_KEY';
    throw _err;
  }

  // Get environment
  var environment = uri.searchParams.get('environment');
  if (!environment) {
    var _err2 = new Error('INVALID_DOTENV_KEY: Missing environment part');
    _err2.code = 'INVALID_DOTENV_KEY';
    throw _err2;
  }

  // Get ciphertext payload
  var environmentKey = "DOTENV_VAULT_".concat(environment.toUpperCase());
  var ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    var _err3 = new Error("NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ".concat(environmentKey, " in your .env.vault file."));
    _err3.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
    throw _err3;
  }
  return {
    ciphertext: ciphertext,
    key: key
  };
}
function _vaultPath(options) {
  var possibleVaultPath = null;
  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      var _iterator = _createForOfIteratorHelper(options.path),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var filepath = _step.value;
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith('.vault') ? filepath : "".concat(filepath, ".vault");
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : "".concat(options.path, ".vault");
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
  }
  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options) {
  _log('Loading env from encrypted .env.vault');
  var parsed = DotenvModule._parseVault(options);
  var processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options);
  return {
    parsed: parsed
  };
}
function configDotenv(options) {
  var dotenvPath = path.resolve(process.cwd(), '.env');
  var encoding = 'utf8';
  var debug = Boolean(options && options.debug);
  if (options) {
    if (options.path != null) {
      var envPath = options.path;
      if (Array.isArray(envPath)) {
        var _iterator2 = _createForOfIteratorHelper(options.path),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var filepath = _step2.value;
            if (fs.existsSync(filepath)) {
              envPath = filepath;
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      dotenvPath = _resolveHome(envPath);
    }
    if (options.encoding != null) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug('No encoding is specified. UTF-8 is used by default');
      }
    }
  }
  try {
    // Specifying an encoding returns a string instead of a buffer
    var parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, {
      encoding: encoding
    }));
    var processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return {
      parsed: parsed
    };
  } catch (e) {
    if (debug) {
      _debug("Failed to load ".concat(dotenvPath, " ").concat(e.message));
    }
    return {
      error: e
    };
  }
}

// Populates process.env from .env file
function config(options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options);
  }
  var vaultPath = _vaultPath(options);

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn("You set DOTENV_KEY but you are missing a .env.vault file at ".concat(vaultPath, ". Did you forget to build it?"));
    return DotenvModule.configDotenv(options);
  }
  return DotenvModule._configVault(options);
}
function decrypt(encrypted, keyStr) {
  var key = Buffer.from(keyStr.slice(-64), 'hex');
  var ciphertext = Buffer.from(encrypted, 'base64');
  var nonce = ciphertext.subarray(0, 12);
  var authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    var aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
    aesgcm.setAuthTag(authTag);
    return "".concat(aesgcm.update(ciphertext)).concat(aesgcm["final"]());
  } catch (error) {
    var isRange = error instanceof RangeError;
    var invalidKeyLength = error.message === 'Invalid key length';
    var decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';
    if (isRange || invalidKeyLength) {
      var err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
      err.code = 'INVALID_DOTENV_KEY';
      throw err;
    } else if (decryptionFailed) {
      var _err4 = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
      _err4.code = 'DECRYPTION_FAILED';
      throw _err4;
    } else {
      throw error;
    }
  }
}

// Populate process.env with parsed values
function populate(processEnv, parsed) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var debug = Boolean(options && options.debug);
  var override = Boolean(options && options.override);
  if (_typeof(parsed) !== 'object') {
    var err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
    err.code = 'OBJECT_REQUIRED';
    throw err;
  }

  // Set process.env
  for (var _i = 0, _Object$keys = Object.keys(parsed); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug) {
        if (override === true) {
          _debug("\"".concat(key, "\" is already defined and WAS overwritten"));
        } else {
          _debug("\"".concat(key, "\" is already defined and was NOT overwritten"));
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
var DotenvModule = {
  configDotenv: configDotenv,
  _configVault: _configVault,
  _parseVault: _parseVault,
  config: config,
  decrypt: decrypt,
  parse: parse,
  populate: populate
};
main$1.exports.configDotenv = DotenvModule.configDotenv;
main$1.exports._configVault = DotenvModule._configVault;
main$1.exports._parseVault = DotenvModule._parseVault;
var config_1 = main$1.exports.config = DotenvModule.config;
main$1.exports.decrypt = DotenvModule.decrypt;
main$1.exports.parse = DotenvModule.parse;
main$1.exports.populate = DotenvModule.populate;
main$1.exports = DotenvModule;

var APIErrorCode = /*#__PURE__*/function (APIErrorCode) {
  APIErrorCode[APIErrorCode["NoError"] = 0] = "NoError";
  APIErrorCode[APIErrorCode["UnknownError"] = 1] = "UnknownError";
  APIErrorCode[APIErrorCode["ServiceUnavailable"] = 2] = "ServiceUnavailable";
  APIErrorCode[APIErrorCode["UnsupportedMethod"] = 3] = "UnsupportedMethod";
  APIErrorCode[APIErrorCode["RequestLimitReached"] = 4] = "RequestLimitReached";
  APIErrorCode[APIErrorCode["NoPermissionToAccessData"] = 6] = "NoPermissionToAccessData";
  APIErrorCode[APIErrorCode["GetServiceTokenFailed"] = 13] = "GetServiceTokenFailed";
  APIErrorCode[APIErrorCode["AppNotExist"] = 15] = "AppNotExist";
  APIErrorCode[APIErrorCode["DailyLimitReached"] = 17] = "DailyLimitReached";
  APIErrorCode[APIErrorCode["QPSLimitReached"] = 18] = "QPSLimitReached";
  APIErrorCode[APIErrorCode["TotalRequestLimitReached"] = 19] = "TotalRequestLimitReached";
  APIErrorCode[APIErrorCode["InvalidRequest"] = 100] = "InvalidRequest";
  APIErrorCode[APIErrorCode["APITokenInvalid"] = 110] = "APITokenInvalid";
  APIErrorCode[APIErrorCode["APITokenExpired"] = 111] = "APITokenExpired";
  APIErrorCode[APIErrorCode["InternalError"] = 336000] = "InternalError";
  APIErrorCode[APIErrorCode["InvalidArgument"] = 336001] = "InvalidArgument";
  APIErrorCode[APIErrorCode["InvalidJSON"] = 336002] = "InvalidJSON";
  APIErrorCode[APIErrorCode["InvalidParam"] = 336003] = "InvalidParam";
  APIErrorCode[APIErrorCode["PermissionError"] = 336004] = "PermissionError";
  APIErrorCode[APIErrorCode["APINameNotExist"] = 336005] = "APINameNotExist";
  APIErrorCode[APIErrorCode["ServerHighLoad"] = 336100] = "ServerHighLoad";
  APIErrorCode[APIErrorCode["InvalidHTTPMethod"] = 336101] = "InvalidHTTPMethod";
  APIErrorCode[APIErrorCode["InvalidArgumentSystem"] = 336104] = "InvalidArgumentSystem";
  APIErrorCode[APIErrorCode["InvalidArgumentUserSetting"] = 336105] = "InvalidArgumentUserSetting";
  APIErrorCode[APIErrorCode["RPMLimitReached"] = 336501] = "RPMLimitReached";
  APIErrorCode[APIErrorCode["TPMLimitReached"] = 336502] = "TPMLimitReached";
  APIErrorCode[APIErrorCode["ConsoleInternalError"] = 500000] = "ConsoleInternalError";
  return APIErrorCode;
}({});

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var BASE_PATH = '/rpc/2.0/ai_custom/v1/wenxinworkshop';
var DEFAULT_HEADERS = {
  'Content-Type': 'application/json',
  Accept: 'application/json'
};
var DEFAULT_CONFIG = {
  QIANFAN_AK: '',
  QIANFAN_SK: '',
  QIANFAN_ACCESS_KEY: '',
  QIANFAN_SECRET_KEY: '',
  QIANFAN_BASE_URL: 'https://aip.baidubce.com',
  QIANFAN_LLM_API_RETRY_TIMEOUT: '600000',
  QIANFAN_LLM_API_RETRY_BACKOFF_FACTOR: '0',
  QIANFAN_LLM_RETRY_MAX_WAIT_INTERVAL: '120000',
  QIANFAN_LLM_API_RETRY_COUNT: '1',
  QIANFAN_QPS_LIMIT: '',
  QIANFAN_RPM_LIMIT: '',
  QIANFAN_TPM_LIMIT: ''
};
var RETRY_CODE = [APIErrorCode.TPMLimitReached, APIErrorCode.ConsoleInternalError, APIErrorCode.ServerHighLoad, APIErrorCode.QPSLimitReached];

config_1();

/**
 * 获取访问令牌的URL地址
 *
 * @param QIANFAN_AK 百度云AK
 * @param QIANFAN_SK 百度云SK
 * @returns 返回访问令牌的URL地址
 */
function getAccessTokenUrl(qianfanAk, qianfanSk, qianfanBaseUrl) {
  // eslint-disable-next-line max-len
  return "".concat(qianfanBaseUrl, "/oauth/2.0/token?grant_type=client_credentials&client_id=").concat(qianfanAk, "&client_secret=").concat(qianfanSk);
}
function getIAMConfig(ak, sk, baseUrl) {
  return {
    credentials: {
      ak: ak,
      sk: sk
    },
    endpoint: baseUrl
  };
}

/**
 * 获取请求体
 *
 * @param body 聊天体
 * @param version 版本号
 * @returns 返回JSON格式的字符串
 */
function getRequestBody(body, version) {
  var modifiedBody = _objectSpread2(_objectSpread2({}, body), {}, {
    extra_parameters: _objectSpread2(_objectSpread2({}, body.extra_parameters), {}, {
      request_source: "qianfan_js_sdk_v".concat(version)
    })
  });
  return JSON.stringify(modifiedBody);
}

/**
 * 获取模型对应的API端点
 * @param model 模型实例
 * @param modelInfoMap 模型信息映射表
 * @returns 返回模型对应的API端点
 * @throws 当模型信息或API端点不存在时抛出异常
 */
function getModelEndpoint(model, modelInfoMap) {
  var modelInfo = modelInfoMap[model];
  if (!modelInfo) {
    throw new Error("Model info not found for model: ".concat(model));
  }
  var endpoint = modelInfo.endpoint;
  if (!endpoint) {
    throw new Error("Endpoint not found for model: ".concat(model));
  }
  return endpoint;
}

/*
 * 获取请求路径
 */
var getPath = function getPath(_ref) {
  var model = _ref.model,
    modelInfoMap = _ref.modelInfoMap,
    Authentication = _ref.Authentication,
    api_base = _ref.api_base,
    _ref$endpoint = _ref.endpoint,
    endpoint = _ref$endpoint === void 0 ? '' : _ref$endpoint,
    type = _ref.type;
  if (endpoint && type) {
    var boundary = type === 'plugin' ? '/' : '';
    return Authentication === 'IAM' ? "".concat(BASE_PATH, "/").concat(type, "/").concat(endpoint).concat(boundary) : "".concat(api_base, "/").concat(type, "/").concat(endpoint).concat(boundary);
  } else if (model && modelInfoMap && modelInfoMap[model]) {
    var modelEndpoint = getModelEndpoint(model, modelInfoMap);
    return Authentication === 'IAM' ? "".concat(BASE_PATH).concat(modelEndpoint) : "".concat(api_base).concat(modelEndpoint);
  }
  throw new Error('invalid model or endpoint');
};
var castToError = function castToError(err) {
  if (err instanceof Error) {
    return err;
  }
  return new Error(err);
};

// 读取单个环境变量
function readEnvVariable(key) {
  return process.env[key];
}

/**
 * 获取默认配置
 *
 * @returns 返回一个字符串类型的键值对对象，包含环境变量
 */
function getDefaultConfig() {
  var envVariables = Object.keys(DEFAULT_CONFIG);
  var obj = {};
  for (var _i = 0, _envVariables = envVariables; _i < _envVariables.length; _i++) {
    var key = _envVariables[_i];
    var value = process.env[key];
    if (value !== undefined) {
      obj[key] = value;
    }
  }
  return Object.assign({}, DEFAULT_CONFIG, obj);
}

// 设置环境变量
function setEnvVariable(key, value) {
  process.env[key] = value;
}

/**
 * 获取路径和请求体
 *
 * @param model 模型
 * @param modelInfoMap 模型信息映射
 * @param body 请求体，可选
 * @param endpoint 请求路径，可选
 * @param type 请求类型，可选
 * @returns 包含路径和请求体的对象
 */
function getPathAndBody(_ref2) {
  var model = _ref2.model,
    modelInfoMap = _ref2.modelInfoMap,
    baseUrl = _ref2.baseUrl,
    body = _ref2.body,
    _ref2$endpoint = _ref2.endpoint,
    endpoint = _ref2$endpoint === void 0 ? '' : _ref2$endpoint,
    type = _ref2.type;
  var api_base = baseUrl + BASE_PATH;
  var IAMPath = getPath({
    model: model,
    modelInfoMap: modelInfoMap,
    Authentication: 'IAM',
    api_base: api_base,
    endpoint: endpoint,
    type: type
  });
  var AKPath = getPath({
    model: model,
    modelInfoMap: modelInfoMap,
    Authentication: 'AK',
    api_base: api_base,
    endpoint: endpoint,
    type: type
  });
  var requestBody = getRequestBody(body, version$3);
  return {
    IAMPath: IAMPath,
    AKPath: AKPath,
    requestBody: requestBody
  };
}

/**
 * 计算重试延迟时间的函数。
 *
 * @param attempt 当前重试尝试的次数。
 * @param backoff_factor 回避因子，用于控制重试延迟的增长速率。
 * @param retry_max_wait_interval 最大重试等待时间间隔，确保重试延迟不会超过此值。
 * @returns 重试延迟时间（毫秒）。
 */
function calculateRetryDelay(attempt) {
  var backoff_factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var retry_max_wait_interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120000;
  return Math.min(retry_max_wait_interval, backoff_factor * Math.pow(2, attempt));
}

/**
 * 检查是否满足打开TPM的条件。
 * 条件包括：环境变量 `QIANFAN_TPM_LIMIT` 设定的限制值（如果存在）和header的 `val` 都必须大于0。
 * @param {number} val - 用于检查的值，预期为正数。
 * @returns {boolean} - 如果满足条件则返回true，否则返回false。
 */
function isOpenTpm(val) {
  var _Number;
  var envToken = (_Number = Number(readEnvVariable('QIANFAN_TPM_LIMIT'))) !== null && _Number !== void 0 ? _Number : 0;
  return envToken > 0 || val > 0;
}

/**
 * 将对象的键名转换为大写形式
 *
 * @param obj 需要转换键名的对象
 * @returns 返回键名已转换为大写形式的新对象
 */
function convertKeysToUppercase(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    var uppercaseKey = key.toUpperCase();
    acc[uppercaseKey] = obj[key];
    return acc;
  }, {});
}

/**
 * 将给定的 model 字符串转换为大写，并将给定的 modelMap 中的键转换为大写形式
 *
 * @param model 需要转换为大写的字符串
 * @param modelMap 可选的 QfLLMInfoMap 类型对象，用于转换键为大写形式
 * @returns 返回包含转换后大写 model 字符串和转换后大写键的 modelMap 对象的对象
 */
function getUpperCaseModelAndModelMap(model, modelMap) {
  if (typeof model !== 'string' || model.trim() === '') {
    return {
      modelInfoMapUppercase: modelMap,
      modelUppercase: ''
    };
  }
  var modelInfoMapUppercase = convertKeysToUppercase(modelMap);
  var modelUppercase = model.toUpperCase();
  return {
    modelInfoMapUppercase: modelInfoMapUppercase,
    modelUppercase: modelUppercase
  };
}

var TokenLimiter = /*#__PURE__*/function () {
  function TokenLimiter(maxTokensPerMinute) {
    var bufferRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
    _classCallCheck(this, TokenLimiter);
    _defineProperty(this, "currentTime", function () {
      return new Date();
    });
    this.bufferRatio = Math.min(Math.max(bufferRatio, 0), 1); // 保证bufferRatio在[0, 1]范围内
    // 使用局部变量缓存环境变量读取结果，避免多次读取
    var envMaxTokens = Number(readEnvVariable('QIANFAN_TPM_LIMIT')) || 0;
    this.initialMaxTokens = maxTokensPerMinute !== null && maxTokensPerMinute !== void 0 ? maxTokensPerMinute : envMaxTokens;
    // 如果未指定最大令牌数且环境变量也未定义，则不执行令牌限制
    if (!this.initialMaxTokens) {
      this.maxTokens = 0; // 设置为0表示无限制
    } else {
      // 使用缓冲区比率调整最大令牌数
      this.maxTokens = Math.floor(this.initialMaxTokens * (1 - this.bufferRatio));
    }
    this.tokens = this.maxTokens;
    this.lastRefreshTime = new Date();
    this.hasReset = false;
    this.mutex = new Mutex();
  }

  /**
   * 获取当前时间所在分钟的开始时间戳
   * @returns {number} 返回当前时间所在分钟的开始时间戳（毫秒）
   */
  _createClass(TokenLimiter, [{
    key: "getTimeAtLastMinute",
    value: function getTimeAtLastMinute() {
      return Math.floor(this.currentTime().getTime() / 60000) * 60000;
    }

    /**
     * 整分刷新令牌
     * @returns Promise<void>
     */
  }, {
    key: "refreshTokens",
    value: (function () {
      var _refreshTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var nowAtMinute;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              nowAtMinute = this.getTimeAtLastMinute();
              if (nowAtMinute !== this.lastRefreshTime.getTime()) {
                this.tokens = this.maxTokens;
                this.lastRefreshTime = new Date(nowAtMinute);
              }
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function refreshTokens() {
        return _refreshTokens.apply(this, arguments);
      }
      return refreshTokens;
    }()
    /**
     * 当前时间开始到下一分钟开始所需等待的时间（以毫秒为单位）
     * 如果在一个时间窗口（例如一分钟）内可用的令牌已经用完，需要等待直到下一个时间窗口开始才能再次填充令牌
     * @returns 等待时间
     */
    )
  }, {
    key: "timeUntilNextMinute",
    value: function timeUntilNextMinute() {
      var now = this.currentTime();
      var nextMinute = new Date(now);
      nextMinute.setMinutes(now.getMinutes() + 1);
      nextMinute.setSeconds(0);
      nextMinute.setMilliseconds(0);
      return nextMinute.getTime() - now.getTime();
    }

    /**
     * 当前是否有指定数量的可用令牌
     * 如果当前令牌数不足，它将计算等待时间直到下一分钟开始，并尝试再次刷新令牌。
     * @param tokenCount 令牌数量
     * @returns 返回Promise<boolean>类型，如果成功获取令牌，则返回true；否则返回false
     */
  }, {
    key: "acquireTokens",
    value: (function () {
      var _acquireTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenCount) {
        var _this = this;
        var unlock;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(this.maxTokens <= 0)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", true);
            case 2:
              _context2.prev = 2;
              _context2.next = 5;
              return this.mutex.lock();
            case 5:
              unlock = _context2.sent;
              _context2.next = 8;
              return this.refreshTokens();
            case 8:
              if (!(this.tokens >= tokenCount)) {
                _context2.next = 11;
                break;
              }
              this.tokens -= tokenCount;
              return _context2.abrupt("return", true);
            case 11:
              _context2.next = 13;
              return new Promise(function (resolve) {
                return setTimeout(resolve, _this.timeUntilNextMinute());
              });
            case 13:
              return _context2.abrupt("return", false);
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](2);
              console.error('Error acquiring tokens:', _context2.t0);
              return _context2.abrupt("return", false);
            case 20:
              _context2.prev = 20;
              if (unlock) {
                unlock();
              }
              return _context2.finish(20);
            case 23:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[2, 16, 20, 23]]);
      }));
      function acquireTokens(_x) {
        return _acquireTokens.apply(this, arguments);
      }
      return acquireTokens;
    }()
    /**
     * 重置令牌
     *
     * @param totalTokens 总的令牌数量
     */
    )
  }, {
    key: "resetTokens",
    value: (function () {
      var _resetTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(totalTokens) {
        var unlock, originalTokenCurrent, originalTokenMax, diff;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              if (!this.hasReset) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              _context3.next = 5;
              return this.mutex.lock();
            case 5:
              unlock = _context3.sent;
              if (!this.hasReset) {
                _context3.next = 8;
                break;
              }
              return _context3.abrupt("return");
            case 8:
              if (!(this.initialMaxTokens === totalTokens)) {
                _context3.next = 10;
                break;
              }
              return _context3.abrupt("return");
            case 10:
              // 之前设置过token
              if (this.maxTokens > 0) {
                totalTokens = Math.min(this.maxTokens, totalTokens);
              }
              originalTokenCurrent = this.tokens;
              originalTokenMax = this.maxTokens;
              diff = originalTokenMax - originalTokenCurrent; // 重新设置最大令牌数，同时考虑缓冲区比率
              this.maxTokens = Math.floor(totalTokens * (1 - this.bufferRatio));
              this.tokens = Math.max(this.maxTokens - diff, 0);
              this.lastRefreshTime = new Date();
              this.hasReset = true;
              _context3.next = 23;
              break;
            case 20:
              _context3.prev = 20;
              _context3.t0 = _context3["catch"](0);
              console.error('Error resetting tokens:', _context3.t0);
            case 23:
              _context3.prev = 23;
              if (unlock) {
                unlock();
              }
              return _context3.finish(23);
            case 26:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 20, 23, 26]]);
      }));
      function resetTokens(_x2) {
        return _resetTokens.apply(this, arguments);
      }
      return resetTokens;
    }()
    /**
     * 计算文本中的 Token 数量
     *
     * @param text 要计算 Token 的文本
     * @returns 返回计算出的 Token 数量
     */
    )
  }, {
    key: "calculateTokens",
    value: function calculateTokens(text) {
      var _text$match, _text$match2;
      var chineseCharactersCount = ((_text$match = text.match(/[\u4e00-\u9fa5]/g)) === null || _text$match === void 0 ? void 0 : _text$match.length) || 0;
      var englishWordCount = ((_text$match2 = text.match(/\b[a-zA-Z]+\b/g)) === null || _text$match2 === void 0 ? void 0 : _text$match2.length) || 0;
      return chineseCharactersCount * 0.625 + englishWordCount;
    }
  }, {
    key: "getTokens",
    value: function getTokens() {
      return this.tokens;
    }
  }, {
    key: "getMaxTokens",
    value: function getMaxTokens() {
      return this.maxTokens;
    }
  }, {
    key: "setHasReset",
    value: function setHasReset(value) {
      this.hasReset = value;
    }
  }]);
  return TokenLimiter;
}();

var RateLimiter = /*#__PURE__*/function () {
  function RateLimiter(queryPerSecond, requestPerMinute) {
    var _this$safeParseInt, _this$safeParseInt2;
    var bufferRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
    _classCallCheck(this, RateLimiter);
    this.qps = (_this$safeParseInt = this.safeParseInt(queryPerSecond)) !== null && _this$safeParseInt !== void 0 ? _this$safeParseInt : Number(readEnvVariable('QIANFAN_QPS_LIMIT'));
    this.rpm = (_this$safeParseInt2 = this.safeParseInt(requestPerMinute)) !== null && _this$safeParseInt2 !== void 0 ? _this$safeParseInt2 : Number(readEnvVariable('QIANFAN_RPM_LIMIT'));
    this.bufferRatio = Math.min(Math.max(bufferRatio, 0), 1); // 保证bufferRatio在[0, 1]范围内
    this.mutex = new Mutex();
    this.hasReset = false;
    this.initializeLimiter();
  }
  _createClass(RateLimiter, [{
    key: "initializeLimiter",
    value: function initializeLimiter() {
      // 如果两者都未设置，则不应用限流
      if (!this.qps && !this.rpm) {
        this.limiter = new Bottleneck({
          minTime: 0,
          highWater: -1,
          strategy: Bottleneck.strategy.OVERFLOW
        });
        return;
      }
      var minTime = Number.MAX_SAFE_INTEGER;
      if (this.qps > 0) {
        minTime = Math.min(minTime, 1000 / this.qps);
      }
      if (this.rpm > 0) {
        minTime = Math.min(minTime, 60000 / this.rpm);
      }
      // 确保 minTime 是一个合理的值
      minTime = Math.max(minTime, 0);
      this.limiter = new Bottleneck({
        minTime: minTime,
        highWater: -1,
        strategy: Bottleneck.strategy.OVERFLOW
      });
    }

    /**
     * 使用限流器调度函数执行
     *
     * @param func 要调度的函数，返回一个Promise<T>
     * @returns 返回Promise<T>类型的调度结果
     */
  }, {
    key: "schedule",
    value: (function () {
      var _schedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(func) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.limiter.schedule(func));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function schedule(_x) {
        return _schedule.apply(this, arguments);
      }
      return schedule;
    }()
    /**
     * 更新限制
     *
     * @param requestPerMinute 每分钟请求次数，可选参数
     */
    )
  }, {
    key: "updateLimits",
    value: (function () {
      var _updateLimits = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(requestPerMinute) {
        var unlock, _this$safeParseInt3;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              if (!this.hasReset) {
                _context2.next = 3;
                break;
              }
              return _context2.abrupt("return");
            case 3:
              _context2.next = 5;
              return this.mutex.lock();
            case 5:
              unlock = _context2.sent;
              if (!this.hasReset) {
                _context2.next = 8;
                break;
              }
              return _context2.abrupt("return");
            case 8:
              if (!(requestPerMinute <= 0)) {
                _context2.next = 10;
                break;
              }
              throw new Error('请求次数必须为正数');
            case 10:
              this.rpm = (_this$safeParseInt3 = this.safeParseInt(requestPerMinute, 'QIANFAN_RPM_LIMIT')) !== null && _this$safeParseInt3 !== void 0 ? _this$safeParseInt3 : this.rpm;
              this.initializeLimiter();
              this.hasReset = true;
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](0);
              console.error('更新限制失败:', _context2.t0);
            case 18:
              _context2.prev = 18;
              if (unlock) {
                unlock();
              }
              return _context2.finish(18);
            case 21:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 15, 18, 21]]);
      }));
      function updateLimits(_x2) {
        return _updateLimits.apply(this, arguments);
      }
      return updateLimits;
    }()
    /**
     * 安全解析整数
     *
     * @param value 要解析的值，可以是数字或字符串
     * @param envVarName 环境变量名，用于输出警告信息
     * @returns 解析后的整数，若解析失败则返回 undefined
     */
    )
  }, {
    key: "safeParseInt",
    value: function safeParseInt(value, envVarName) {
      if (!value) {
        return;
      }
      var parsedValue = Number.parseInt(String(value), 10);
      if (isNaN(parsedValue) || parsedValue < 0) {
        console.warn("Invalid value for ".concat(envVarName, ": ").concat(value, ". Using undefined."));
        return undefined;
      }
      return parsedValue;
    }
  }]);
  return RateLimiter;
}();

var Fetch = /*#__PURE__*/function () {
  function Fetch() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$retries = _ref.retries,
      retries = _ref$retries === void 0 ? 3 : _ref$retries,
      _ref$timeout = _ref.timeout,
      timeout = _ref$timeout === void 0 ? 5000 : _ref$timeout,
      _ref$retryDelay = _ref.retryDelay,
      retryDelay = _ref$retryDelay === void 0 ? function (attempt) {
        return 1000 * Math.pow(2, attempt);
      } : _ref$retryDelay,
      _ref$retryOn = _ref.retryOn,
      retryOn = _ref$retryOn === void 0 ? [] : _ref$retryOn;
    _classCallCheck(this, Fetch);
    this.retries = retries;
    this.timeout = timeout;
    this.retryDelay = retryDelay;
    this.retryOn = retryOn;
    this.rateLimiter = new RateLimiter();
  }
  _createClass(Fetch, [{
    key: "fetchWithRetry",
    value: function () {
      var _fetchWithRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url) {
        var _this = this;
        var options,
          fetchWithTimeout,
          isJsonResponse,
          shouldRetry,
          makeRequest,
          _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
              fetchWithTimeout = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, options) {
                  var controller, timer, _response;
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        controller = new AbortController();
                        timer = setTimeout(function () {
                          return controller.abort();
                        }, options.timeout || _this.timeout);
                        options.signal = controller.signal;
                        _context.prev = 3;
                        _context.next = 6;
                        return fetch(url, options);
                      case 6:
                        _response = _context.sent;
                        return _context.abrupt("return", _response);
                      case 10:
                        _context.prev = 10;
                        _context.t0 = _context["catch"](3);
                        throw _context.t0;
                      case 13:
                        _context.prev = 13;
                        clearTimeout(timer);
                        return _context.finish(13);
                      case 16:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee, null, [[3, 10, 13, 16]]);
                }));
                return function fetchWithTimeout(_x2, _x3) {
                  return _ref2.apply(this, arguments);
                };
              }();
              isJsonResponse = function isJsonResponse(response) {
                var contentType = response.headers.get('Content-Type');
                return contentType && contentType.includes('application/json');
              };
              shouldRetry = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(response, error) {
                  var data, errorMessage;
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!((error === null || error === void 0 ? void 0 : error.name) === 'AbortError')) {
                          _context2.next = 2;
                          break;
                        }
                        return _context2.abrupt("return", false);
                      case 2:
                        if (!(response !== null && response !== void 0 && response.ok && isJsonResponse(response))) {
                          _context2.next = 16;
                          break;
                        }
                        _context2.prev = 3;
                        _context2.next = 6;
                        return response.clone().json();
                      case 6:
                        data = _context2.sent;
                        if (!(data !== null && data !== void 0 && data.error_code && !RETRY_CODE.includes(data === null || data === void 0 ? void 0 : data.error_code))) {
                          _context2.next = 10;
                          break;
                        }
                        errorMessage = JSON.stringify(data);
                        throw new Error(errorMessage);
                      case 10:
                        return _context2.abrupt("return", RETRY_CODE.includes(data === null || data === void 0 ? void 0 : data.error_code));
                      case 13:
                        _context2.prev = 13;
                        _context2.t0 = _context2["catch"](3);
                        throw new Error(_context2.t0);
                      case 16:
                        return _context2.abrupt("return", false);
                      case 17:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2, null, [[3, 13]]);
                }));
                return function shouldRetry(_x4, _x5) {
                  return _ref3.apply(this, arguments);
                };
              }();
              makeRequest = /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  var attempt, _loop, _ret;
                  return _regeneratorRuntime().wrap(function _callee3$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        attempt = 0;
                        _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                          var _response2, rpm, retry, delay, _delay;
                          return _regeneratorRuntime().wrap(function _loop$(_context3) {
                            while (1) switch (_context3.prev = _context3.next) {
                              case 0:
                                _context3.prev = 0;
                                _context3.next = 3;
                                return _this.rateLimiter.schedule(function () {
                                  return fetchWithTimeout(url, _objectSpread2(_objectSpread2({}, options), {}, {
                                    timeout: _this.timeout
                                  }));
                                });
                              case 3:
                                _response2 = _context3.sent;
                                rpm = _response2.headers.get('x-ratelimit-limit-requests');
                                if (rpm) {
                                  _this.rateLimiter.updateLimits(Number(rpm));
                                }
                                // 注意：现在 shouldRetry 可能会直接抛出异常
                                _context3.next = 8;
                                return shouldRetry(_response2);
                              case 8:
                                retry = _context3.sent;
                                if (!retry) {
                                  _context3.next = 15;
                                  break;
                                }
                                attempt++;
                                delay = typeof _this.retryDelay === 'function' ? _this.retryDelay(attempt) : _this.retryDelay;
                                _context3.next = 14;
                                return new Promise(function (resolve) {
                                  return setTimeout(resolve, delay);
                                });
                              case 14:
                                return _context3.abrupt("return", 0);
                              case 15:
                                return _context3.abrupt("return", {
                                  v: _response2
                                });
                              case 18:
                                _context3.prev = 18;
                                _context3.t0 = _context3["catch"](0);
                                _context3.next = 22;
                                return shouldRetry(undefined, _context3.t0);
                              case 22:
                                if (!_context3.sent) {
                                  _context3.next = 28;
                                  break;
                                }
                                attempt++;
                                _delay = typeof _this.retryDelay === 'function' ? _this.retryDelay(attempt) : _this.retryDelay;
                                _context3.next = 27;
                                return new Promise(function (resolve) {
                                  return setTimeout(resolve, _delay);
                                });
                              case 27:
                                return _context3.abrupt("return", 0);
                              case 28:
                                throw _context3.t0;
                              case 29:
                              case "end":
                                return _context3.stop();
                            }
                          }, _loop, null, [[0, 18]]);
                        });
                      case 2:
                        if (!(attempt < _this.retries)) {
                          _context4.next = 11;
                          break;
                        }
                        return _context4.delegateYield(_loop(), "t0", 4);
                      case 4:
                        _ret = _context4.t0;
                        if (!(_ret === 0)) {
                          _context4.next = 7;
                          break;
                        }
                        return _context4.abrupt("continue", 2);
                      case 7:
                        if (!_ret) {
                          _context4.next = 9;
                          break;
                        }
                        return _context4.abrupt("return", _ret.v);
                      case 9:
                        _context4.next = 2;
                        break;
                      case 11:
                        throw new Error('All retry attempts failed.');
                      case 12:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee3);
                }));
                return function makeRequest() {
                  return _ref4.apply(this, arguments);
                };
              }();
              return _context5.abrupt("return", makeRequest());
            case 6:
            case "end":
              return _context5.stop();
          }
        }, _callee4);
      }));
      function fetchWithRetry(_x) {
        return _fetchWithRetry.apply(this, arguments);
      }
      return fetchWithRetry;
    }()
  }]);
  return Fetch;
}();

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var CONTENT_TYPE = 'Content-Type';
var CONTENT_LENGTH = 'Content-Length';
var CONTENT_MD5 = 'Content-MD5';
var HOST = 'Host';
var USER_AGENT = 'User-Agent';

/** BOS 相关headers */
var AUTHORIZATION = 'Authorization';
var X_BCE_DATE = 'x-bce-date';

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var kEscapedMap = {
  '!': '%21',
  '\'': '%27',
  '(': '%28',
  ')': '%29',
  '*': '%2A'
};
function normalize(string, encodingSlash) {
  var result = encodeURIComponent(string);
  result = result.replace(/[!'\(\)\*]/g, function ($1) {
    return kEscapedMap[$1];
  });
  if (encodingSlash === false) {
    result = result.replace(/%2F/gi, '/');
  }
  return result;
}
function trim(string) {
  return (string || '').replace(/^\s+|\s+$/g, '');
}
function urlObjectToPlainObject(url, httpMethod, headers) {
  return {
    protocol: url.protocol,
    auth: url.username || (url.password ? '****:' : '') + url.password,
    host: url.host,
    port: url.port,
    hostname: url.hostname,
    hash: url.hash,
    search: url.search,
    query: url.searchParams.toString(),
    pathname: url.pathname,
    path: url.pathname + url.search,
    href: url.href,
    method: httpMethod,
    headers: headers
  };
}

var debug = createDebug('bce-sdk:Auth');
var Auth = /*#__PURE__*/function () {
  function Auth(ak, sk) {
    _classCallCheck(this, Auth);
    this.ak = ak;
    this.sk = sk;
  }
  _createClass(Auth, [{
    key: "generateAuthorization",
    value: function generateAuthorization(method, resource, params, headers, timestamp, expirationInSeconds, headersToSign) {
      var now = this.getTimestamp(timestamp);
      var rawSessionKey = util.format('bce-auth-v1/%s/%s/%d', this.ak, now, expirationInSeconds || 1800);
      debug('rawSessionKey = %j', rawSessionKey);
      var sessionKey = this.hash(rawSessionKey, this.sk);
      var canonicalUri = this.generateCanonicalUri(resource);
      var canonicalQueryString = this.queryStringCanonicalization(params || {});
      var rv = this.headersCanonicalization(headers || {}, headersToSign);
      var canonicalHeaders = rv[0];
      var signedHeaders = rv[1];
      debug('canonicalUri = %j', canonicalUri);
      debug('canonicalQueryString = %j', canonicalQueryString);
      debug('canonicalHeaders = %j', canonicalHeaders);
      debug('signedHeaders = %j', signedHeaders);
      var rawSignature = util.format('%s\n%s\n%s\n%s', method, canonicalUri, canonicalQueryString, canonicalHeaders);
      debug('rawSignature = %j', rawSignature);
      debug('sessionKey = %j', sessionKey);
      var signature = this.hash(rawSignature, sessionKey);
      if (signedHeaders.length) {
        return util.format('%s/%s/%s', rawSessionKey, signedHeaders.join(';'), signature);
      }
      return util.format('%s//%s', rawSessionKey, signature);
    }
  }, {
    key: "normalize",
    value: function normalize(string) {
      var encodingSlash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var kEscapedMap = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '*': '%2A'
      };
      if (string === null) {
        return '';
      }
      var result = encodeURIComponent(string);
      result = result.replace(/[!'\(\)\*]/g, function ($1) {
        return kEscapedMap[$1];
      });
      if (!encodingSlash) {
        result = result.replace(/%2F/gi, '/');
      }
      return result;
    }
  }, {
    key: "getTimestamp",
    value: function getTimestamp(timestamp) {
      var now = timestamp ? new Date(timestamp * 1000) : new Date();
      return now.toISOString().replace(/\.\d+Z$/, 'Z');
    }
  }, {
    key: "generateCanonicalUri",
    value: function generateCanonicalUri(url) {
      if (!(url !== null && url !== void 0 && url.includes('bos-share.baidubce.com'))) {
        return url;
      }
      var urlObj = new URL(url);
      var pathname = urlObj.pathname.trim();
      var resources = pathname.replace(/^\//, '').split('/');
      if (!resources) {
        return '';
      }
      var normalizedResourceStr = '';
      for (var i = 0; i < resources.length; i++) {
        normalizedResourceStr += '/' + this.normalize(resources[i]);
      }
      return normalizedResourceStr;
    }
  }, {
    key: "queryStringCanonicalization",
    value: function queryStringCanonicalization(params) {
      var _this = this;
      var canonicalQueryString = [];
      Object.keys(params).forEach(function (key) {
        if (key.toLowerCase() === AUTHORIZATION.toLowerCase()) {
          return;
        }
        var value = params[key] == null ? '' : params[key];
        canonicalQueryString.push("".concat(key, "=").concat(_this.normalize(value)));
      });
      canonicalQueryString.sort();
      return canonicalQueryString.join('&');
    }
  }, {
    key: "headersCanonicalization",
    value: function headersCanonicalization(headers, headersToSign) {
      if (!headersToSign || !headersToSign.length) {
        headersToSign = [HOST, CONTENT_MD5, CONTENT_LENGTH, CONTENT_TYPE];
      }
      debug('headers = %j, headersToSign = %j', headers, headersToSign);
      var headersMap = {};
      headersToSign.forEach(function (item) {
        headersMap[item.toLowerCase()] = true;
      });
      var canonicalHeaders = [];
      Object.keys(headers).forEach(function (key) {
        var value = headers[key];
        value = _.isString(value) ? trim(value) : value;
        if (value == null || value === '') {
          return;
        }
        key = key.toLowerCase();
        if (/^x\-bce\-/.test(key) || headersMap[key] === true) {
          canonicalHeaders.push(util.format('%s:%s', normalize(key), normalize(value)));
        }
      });
      canonicalHeaders.sort();
      var signedHeaders = [];
      canonicalHeaders.forEach(function (item) {
        signedHeaders.push(item.split(':')[0]);
      });
      return [canonicalHeaders.join('\n'), signedHeaders];
    }
  }, {
    key: "hash",
    value: function hash(data, key) {
      var sha256Hmac = require$$3.createHmac('sha256', key);
      sha256Hmac.update(data);
      return sha256Hmac.digest('hex');
    }
  }]);
  return Auth;
}();

var OpenAIError = /*#__PURE__*/function (_Error) {
  _inherits(OpenAIError, _Error);
  function OpenAIError() {
    _classCallCheck(this, OpenAIError);
    return _callSuper(this, OpenAIError, arguments);
  }
  return _createClass(OpenAIError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var APIError = /*#__PURE__*/function (_OpenAIError) {
  _inherits(APIError, _OpenAIError);
  function APIError(status, error, message, headers) {
    var _this;
    _classCallCheck(this, APIError);
    _this = _callSuper(this, APIError, ["".concat(APIError.makeMessage(status, error, message))]);
    _this.status = status;
    _this.headers = headers;
    var data = error;
    _this.error = data;
    _this.code = data === null || data === void 0 ? void 0 : data.code;
    _this.param = data === null || data === void 0 ? void 0 : data.param;
    _this.type = data === null || data === void 0 ? void 0 : data.type;
    return _this;
  }
  _createClass(APIError, null, [{
    key: "makeMessage",
    value: function makeMessage(status, error, message) {
      var msg = error !== null && error !== void 0 && error.message ? typeof error.message === 'string' ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return "".concat(status, " ").concat(msg);
      }
      if (status) {
        return "".concat(status, " status code (no body)");
      }
      if (msg) {
        return msg;
      }
      return '(no status code or body)';
    }
  }, {
    key: "generate",
    value: function generate(status, errorResponse, message, headers) {
      if (!status) {
        return new APIConnectionError({
          cause: castToError(errorResponse)
        });
      }
      var error = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error;
      if (status === 400) {
        return new BadRequestError(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError(status, error, message, headers);
      }
      return new APIError(status, error, message, headers);
    }
  }]);
  return APIError;
}(OpenAIError);
var APIConnectionError = /*#__PURE__*/function (_APIError2) {
  _inherits(APIConnectionError, _APIError2);
  function APIConnectionError(_ref2) {
    var _this3;
    var message = _ref2.message,
      cause = _ref2.cause;
    _classCallCheck(this, APIConnectionError);
    _this3 = _callSuper(this, APIConnectionError, [undefined, undefined, message || 'Connection error.', undefined]);
    // in some environments the 'cause' property is already declared
    // @ts-ignore
    _defineProperty(_assertThisInitialized(_this3), "status", undefined);
    if (cause) {
      _this3.cause = cause;
    }
    return _this3;
  }
  return _createClass(APIConnectionError);
}(APIError);
var BadRequestError = /*#__PURE__*/function (_APIError3) {
  _inherits(BadRequestError, _APIError3);
  function BadRequestError() {
    var _this4;
    _classCallCheck(this, BadRequestError);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this4 = _callSuper(this, BadRequestError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this4), "status", 400);
    return _this4;
  }
  return _createClass(BadRequestError);
}(APIError);
var AuthenticationError = /*#__PURE__*/function (_APIError4) {
  _inherits(AuthenticationError, _APIError4);
  function AuthenticationError() {
    var _this5;
    _classCallCheck(this, AuthenticationError);
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    _this5 = _callSuper(this, AuthenticationError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this5), "status", 401);
    return _this5;
  }
  return _createClass(AuthenticationError);
}(APIError);
var PermissionDeniedError = /*#__PURE__*/function (_APIError5) {
  _inherits(PermissionDeniedError, _APIError5);
  function PermissionDeniedError() {
    var _this6;
    _classCallCheck(this, PermissionDeniedError);
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    _this6 = _callSuper(this, PermissionDeniedError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this6), "status", 403);
    return _this6;
  }
  return _createClass(PermissionDeniedError);
}(APIError);
var NotFoundError = /*#__PURE__*/function (_APIError6) {
  _inherits(NotFoundError, _APIError6);
  function NotFoundError() {
    var _this7;
    _classCallCheck(this, NotFoundError);
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    _this7 = _callSuper(this, NotFoundError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this7), "status", 404);
    return _this7;
  }
  return _createClass(NotFoundError);
}(APIError);
var ConflictError = /*#__PURE__*/function (_APIError7) {
  _inherits(ConflictError, _APIError7);
  function ConflictError() {
    var _this8;
    _classCallCheck(this, ConflictError);
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    _this8 = _callSuper(this, ConflictError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this8), "status", 409);
    return _this8;
  }
  return _createClass(ConflictError);
}(APIError);
var UnprocessableEntityError = /*#__PURE__*/function (_APIError8) {
  _inherits(UnprocessableEntityError, _APIError8);
  function UnprocessableEntityError() {
    var _this9;
    _classCallCheck(this, UnprocessableEntityError);
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    _this9 = _callSuper(this, UnprocessableEntityError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this9), "status", 422);
    return _this9;
  }
  return _createClass(UnprocessableEntityError);
}(APIError);
var RateLimitError = /*#__PURE__*/function (_APIError9) {
  _inherits(RateLimitError, _APIError9);
  function RateLimitError() {
    var _this10;
    _classCallCheck(this, RateLimitError);
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    _this10 = _callSuper(this, RateLimitError, [].concat(args));
    _defineProperty(_assertThisInitialized(_this10), "status", 429);
    return _this10;
  }
  return _createClass(RateLimitError);
}(APIError);
var InternalServerError = /*#__PURE__*/function (_APIError10) {
  _inherits(InternalServerError, _APIError10);
  function InternalServerError() {
    _classCallCheck(this, InternalServerError);
    return _callSuper(this, InternalServerError, arguments);
  }
  return _createClass(InternalServerError);
}(APIError);

var EVENT_TYPE = [null, 'pluginMeta', 'plugin', 'chat'];
var SSEDecoder = /*#__PURE__*/function () {
  function SSEDecoder() {
    _classCallCheck(this, SSEDecoder);
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  _createClass(SSEDecoder, [{
    key: "decode",
    value: function decode(line) {
      if (line.endsWith('\r')) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length) {
          return null;
        }
        var sse = {
          event: this.event,
          data: this.data.join('\n'),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(':')) {
        return null;
      }
      var _partition = partition(line, ':'),
        _partition2 = _slicedToArray(_partition, 3),
        fieldname = _partition2[0];
        _partition2[1];
        var value = _partition2[2];
      if (value.startsWith(' ')) {
        value = value.substring(1);
      }
      if (fieldname === 'event') {
        this.event = value;
      } else if (fieldname === 'data') {
        this.data.push(value);
      }
      return null;
    }
  }]);
  return SSEDecoder;
}();
/**
 * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally
 * reading lines from text.
 *
 * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258
 */
var LineDecoder = /*#__PURE__*/function () {
  // TextDecoder found in browsers; not typed to avoid pulling in either "dom" or "node" types.

  function LineDecoder() {
    _classCallCheck(this, LineDecoder);
    this.buffer = [];
    this.trailingCR = false;
  }
  _createClass(LineDecoder, [{
    key: "decode",
    value: function decode(chunk) {
      var text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = '\r' + text;
        this.trailingCR = false;
      }
      if (text.endsWith('\r')) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      var trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');
      var lines = text.split(LineDecoder.NEWLINE_REGEXP);
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join('') + lines[0]].concat(_toConsumableArray(lines.slice(1)));
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ''];
      }
      return lines;
    }
  }, {
    key: "decodeText",
    value: function decodeText(bytes) {
      if (bytes == null) {
        return '';
      }
      if (typeof bytes === 'string') {
        return bytes;
      }

      // Node:
      if (typeof Buffer !== 'undefined') {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new OpenAIError( // eslint-disable-next-line max-len
        "Unexpected: received non-Uint8Array (".concat(bytes.constructor.name, ") stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error."));
      }

      // Browser
      if (typeof TextDecoder !== 'undefined') {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          var _this$textDecoder;
          (_this$textDecoder = this.textDecoder) !== null && _this$textDecoder !== void 0 ? _this$textDecoder : this.textDecoder = new TextDecoder('utf8');
          return this.textDecoder.decode(bytes);
        }
        throw new OpenAIError("Unexpected: received non-Uint8Array/ArrayBuffer (".concat(bytes.constructor.name, ") in a web platform. Please report this error."));
      }
      throw new OpenAIError('Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.');
    }
  }, {
    key: "flush",
    value: function flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      var lines = [this.buffer.join('')];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  }]);
  return LineDecoder;
}();
// prettier-ignore
_defineProperty(LineDecoder, "NEWLINE_CHARS", new Set(['\n', '\r', '\x0b', '\x0c', '\x1c', '\x1d', '\x1e', '\x85', "\u2028", "\u2029"]));
_defineProperty(LineDecoder, "NEWLINE_REGEXP", /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g);
var Stream = /*#__PURE__*/function (_EventEmitter, _Symbol$asyncIterator) {
  _inherits(Stream, _EventEmitter);
  function Stream(iterator, controller) {
    var _this;
    _classCallCheck(this, Stream);
    _this = _callSuper(this, Stream);
    _this.iterator = iterator;
    _this.controller = controller;
    return _this;
  }
  _createClass(Stream, [{
    key: _Symbol$asyncIterator,
    value: function value() {
      return this.iterator();
    }

    /**
    * 将一个流复制成两个流
    *
    * @returns 返回一个由两个流组成的元组
    */
  }, {
    key: "tee",
    value: function tee() {
      var left = [];
      var right = [];
      var iterator = this.iterator();
      var teeIterator = function teeIterator(queue) {
        return {
          next: function next() {
            if (queue.length === 0) {
              var result = iterator.next();
              left.push(result);
              right.push(result);
            }
            return queue.shift();
          }
        };
      };
      return [new Stream(function () {
        return teeIterator(left);
      }, this.controller), new Stream(function () {
        return teeIterator(right);
      }, this.controller)];
    }

    /**
    * 将可迭代对象转换为可读流
    *
    * @returns 返回一个可读流
    */
  }, {
    key: "toReadableStream",
    value: function toReadableStream() {
      var self = this;
      var iter;
      var encoder = new TextEncoder();
      return new ReadableStream({
        start: function start() {
          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  iter = self[Symbol.asyncIterator]();
                case 1:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }))();
        },
        pull: function pull(ctrl) {
          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            var _yield$iter$next, value, done, bytes;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return iter.next();
                case 3:
                  _yield$iter$next = _context2.sent;
                  value = _yield$iter$next.value;
                  done = _yield$iter$next.done;
                  if (!done) {
                    _context2.next = 8;
                    break;
                  }
                  return _context2.abrupt("return", ctrl.close());
                case 8:
                  bytes = encoder.encode(JSON.stringify(value) + '\n');
                  ctrl.enqueue(bytes);
                  _context2.next = 15;
                  break;
                case 12:
                  _context2.prev = 12;
                  _context2.t0 = _context2["catch"](0);
                  ctrl.error(_context2.t0);
                case 15:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, null, [[0, 12]]);
          }))();
        },
        cancel: function cancel() {
          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
            var _iter$return, _iter;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return (_iter$return = (_iter = iter)["return"]) === null || _iter$return === void 0 ? void 0 : _iter$return.call(_iter);
                case 2:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }))();
        }
      });
    }
  }], [{
    key: "fromSSEResponse",
    value: function fromSSEResponse(response, controller) {
      var consumed = false;
      var decoder = new SSEDecoder();
      function iterMessages() {
        return _iterMessages.apply(this, arguments);
      }
      function _iterMessages() {
        _iterMessages = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var lineDecoder, iter, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, _iterator7, _step5, line, sse, _iterator8, _step6, _line, _sse;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                if (response.body) {
                  _context4.next = 3;
                  break;
                }
                controller.abort();
                throw new OpenAIError('Attempted to iterate over a response with no body');
              case 3:
                lineDecoder = new LineDecoder();
                iter = readableStreamAsyncIterable(response.body);
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context4.prev = 7;
                _iterator = _asyncIterator(iter);
              case 9:
                _context4.next = 11;
                return _awaitAsyncGenerator(_iterator.next());
              case 11:
                if (!(_iteratorAbruptCompletion = !(_step = _context4.sent).done)) {
                  _context4.next = 35;
                  break;
                }
                chunk = _step.value;
                _iterator7 = _createForOfIteratorHelper(lineDecoder.decode(chunk));
                _context4.prev = 14;
                _iterator7.s();
              case 16:
                if ((_step5 = _iterator7.n()).done) {
                  _context4.next = 24;
                  break;
                }
                line = _step5.value;
                sse = decoder.decode(line);
                if (!sse) {
                  _context4.next = 22;
                  break;
                }
                _context4.next = 22;
                return sse;
              case 22:
                _context4.next = 16;
                break;
              case 24:
                _context4.next = 29;
                break;
              case 26:
                _context4.prev = 26;
                _context4.t0 = _context4["catch"](14);
                _iterator7.e(_context4.t0);
              case 29:
                _context4.prev = 29;
                _iterator7.f();
                return _context4.finish(29);
              case 32:
                _iteratorAbruptCompletion = false;
                _context4.next = 9;
                break;
              case 35:
                _context4.next = 41;
                break;
              case 37:
                _context4.prev = 37;
                _context4.t1 = _context4["catch"](7);
                _didIteratorError = true;
                _iteratorError = _context4.t1;
              case 41:
                _context4.prev = 41;
                _context4.prev = 42;
                if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                  _context4.next = 46;
                  break;
                }
                _context4.next = 46;
                return _awaitAsyncGenerator(_iterator["return"]());
              case 46:
                _context4.prev = 46;
                if (!_didIteratorError) {
                  _context4.next = 49;
                  break;
                }
                throw _iteratorError;
              case 49:
                return _context4.finish(46);
              case 50:
                return _context4.finish(41);
              case 51:
                _iterator8 = _createForOfIteratorHelper(lineDecoder.flush());
                _context4.prev = 52;
                _iterator8.s();
              case 54:
                if ((_step6 = _iterator8.n()).done) {
                  _context4.next = 62;
                  break;
                }
                _line = _step6.value;
                _sse = decoder.decode(_line);
                if (!_sse) {
                  _context4.next = 60;
                  break;
                }
                _context4.next = 60;
                return _sse;
              case 60:
                _context4.next = 54;
                break;
              case 62:
                _context4.next = 67;
                break;
              case 64:
                _context4.prev = 64;
                _context4.t2 = _context4["catch"](52);
                _iterator8.e(_context4.t2);
              case 67:
                _context4.prev = 67;
                _iterator8.f();
                return _context4.finish(67);
              case 70:
              case "end":
                return _context4.stop();
            }
          }, _callee4, null, [[7, 37, 41, 51], [14, 26, 29, 32], [42,, 46, 50], [52, 64, 67, 70]]);
        }));
        return _iterMessages.apply(this, arguments);
      }
      function iterator() {
        return _iterator3.apply(this, arguments);
      }
      function _iterator3() {
        _iterator3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var done, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, sse, data;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                if (!consumed) {
                  _context5.next = 2;
                  break;
                }
                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
              case 2:
                consumed = true;
                done = false;
                _context5.prev = 4;
                _iteratorAbruptCompletion2 = false;
                _didIteratorError2 = false;
                _context5.prev = 7;
                _iterator2 = _asyncIterator(iterMessages());
              case 9:
                _context5.next = 11;
                return _awaitAsyncGenerator(_iterator2.next());
              case 11:
                if (!(_iteratorAbruptCompletion2 = !(_step2 = _context5.sent).done)) {
                  _context5.next = 37;
                  break;
                }
                sse = _step2.value;
                if (!done) {
                  _context5.next = 15;
                  break;
                }
                return _context5.abrupt("continue", 34);
              case 15:
                if (!sse.data.startsWith('[DONE]')) {
                  _context5.next = 18;
                  break;
                }
                done = true;
                return _context5.abrupt("continue", 34);
              case 18:
                if (!EVENT_TYPE.includes(sse.event)) {
                  _context5.next = 34;
                  break;
                }
                data = void 0;
                _context5.prev = 20;
                data = JSON.parse(sse.data);
                this.emit('data', data);
                _context5.next = 30;
                break;
              case 25:
                _context5.prev = 25;
                _context5.t0 = _context5["catch"](20);
                console.error('Could not parse message into JSON:', sse.data);
                console.error('From chunk:', sse.raw);
                throw _context5.t0;
              case 30:
                if (!(data && data.error)) {
                  _context5.next = 32;
                  break;
                }
                throw new APIError(undefined, data.error, undefined, undefined);
              case 32:
                _context5.next = 34;
                return data;
              case 34:
                _iteratorAbruptCompletion2 = false;
                _context5.next = 9;
                break;
              case 37:
                _context5.next = 43;
                break;
              case 39:
                _context5.prev = 39;
                _context5.t1 = _context5["catch"](7);
                _didIteratorError2 = true;
                _iteratorError2 = _context5.t1;
              case 43:
                _context5.prev = 43;
                _context5.prev = 44;
                if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                  _context5.next = 48;
                  break;
                }
                _context5.next = 48;
                return _awaitAsyncGenerator(_iterator2["return"]());
              case 48:
                _context5.prev = 48;
                if (!_didIteratorError2) {
                  _context5.next = 51;
                  break;
                }
                throw _iteratorError2;
              case 51:
                return _context5.finish(48);
              case 52:
                return _context5.finish(43);
              case 53:
                done = true;
                _context5.next = 61;
                break;
              case 56:
                _context5.prev = 56;
                _context5.t2 = _context5["catch"](4);
                if (!(_context5.t2 instanceof Error && _context5.t2.name === 'AbortError')) {
                  _context5.next = 60;
                  break;
                }
                return _context5.abrupt("return");
              case 60:
                throw _context5.t2;
              case 61:
                _context5.prev = 61;
                // If the user `break`s, abort the ongoing request.
                if (!done) {
                  controller.abort();
                }
                return _context5.finish(61);
              case 64:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this, [[4, 56, 61, 64], [7, 39, 43, 53], [20, 25], [44,, 48, 52]]);
        }));
        return _iterator3.apply(this, arguments);
      }
      return new Stream(iterator, controller);
    }

    /**
    * 从可读流中读取数据，并返回一个流对象
    *
    * @param readableStream 可读流
    * @param controller 控制器
    * @returns 返回一个流对象
    */
  }, {
    key: "fromReadableStream",
    value: function fromReadableStream(readableStream, controller) {
      var consumed = false;
      function iterLines() {
        return _iterLines.apply(this, arguments);
      }
      function _iterLines() {
        _iterLines = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          var lineDecoder, iter, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator4, _step3, chunk, _iterator9, _step7, line, _iterator10, _step8, _line2;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                lineDecoder = new LineDecoder();
                iter = readableStreamAsyncIterable(readableStream);
                _iteratorAbruptCompletion3 = false;
                _didIteratorError3 = false;
                _context6.prev = 4;
                _iterator4 = _asyncIterator(iter);
              case 6:
                _context6.next = 8;
                return _awaitAsyncGenerator(_iterator4.next());
              case 8:
                if (!(_iteratorAbruptCompletion3 = !(_step3 = _context6.sent).done)) {
                  _context6.next = 30;
                  break;
                }
                chunk = _step3.value;
                _iterator9 = _createForOfIteratorHelper(lineDecoder.decode(chunk));
                _context6.prev = 11;
                _iterator9.s();
              case 13:
                if ((_step7 = _iterator9.n()).done) {
                  _context6.next = 19;
                  break;
                }
                line = _step7.value;
                _context6.next = 17;
                return line;
              case 17:
                _context6.next = 13;
                break;
              case 19:
                _context6.next = 24;
                break;
              case 21:
                _context6.prev = 21;
                _context6.t0 = _context6["catch"](11);
                _iterator9.e(_context6.t0);
              case 24:
                _context6.prev = 24;
                _iterator9.f();
                return _context6.finish(24);
              case 27:
                _iteratorAbruptCompletion3 = false;
                _context6.next = 6;
                break;
              case 30:
                _context6.next = 36;
                break;
              case 32:
                _context6.prev = 32;
                _context6.t1 = _context6["catch"](4);
                _didIteratorError3 = true;
                _iteratorError3 = _context6.t1;
              case 36:
                _context6.prev = 36;
                _context6.prev = 37;
                if (!(_iteratorAbruptCompletion3 && _iterator4["return"] != null)) {
                  _context6.next = 41;
                  break;
                }
                _context6.next = 41;
                return _awaitAsyncGenerator(_iterator4["return"]());
              case 41:
                _context6.prev = 41;
                if (!_didIteratorError3) {
                  _context6.next = 44;
                  break;
                }
                throw _iteratorError3;
              case 44:
                return _context6.finish(41);
              case 45:
                return _context6.finish(36);
              case 46:
                _iterator10 = _createForOfIteratorHelper(lineDecoder.flush());
                _context6.prev = 47;
                _iterator10.s();
              case 49:
                if ((_step8 = _iterator10.n()).done) {
                  _context6.next = 55;
                  break;
                }
                _line2 = _step8.value;
                _context6.next = 53;
                return _line2;
              case 53:
                _context6.next = 49;
                break;
              case 55:
                _context6.next = 60;
                break;
              case 57:
                _context6.prev = 57;
                _context6.t2 = _context6["catch"](47);
                _iterator10.e(_context6.t2);
              case 60:
                _context6.prev = 60;
                _iterator10.f();
                return _context6.finish(60);
              case 63:
              case "end":
                return _context6.stop();
            }
          }, _callee6, null, [[4, 32, 36, 46], [11, 21, 24, 27], [37,, 41, 45], [47, 57, 60, 63]]);
        }));
        return _iterLines.apply(this, arguments);
      }
      function iterator() {
        return _iterator6.apply(this, arguments);
      }
      function _iterator6() {
        _iterator6 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          var done, _iteratorAbruptCompletion4, _didIteratorError4, _iteratorError4, _iterator5, _step4, line;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                if (!consumed) {
                  _context7.next = 2;
                  break;
                }
                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
              case 2:
                consumed = true;
                done = false;
                _context7.prev = 4;
                _iteratorAbruptCompletion4 = false;
                _didIteratorError4 = false;
                _context7.prev = 7;
                _iterator5 = _asyncIterator(iterLines());
              case 9:
                _context7.next = 11;
                return _awaitAsyncGenerator(_iterator5.next());
              case 11:
                if (!(_iteratorAbruptCompletion4 = !(_step4 = _context7.sent).done)) {
                  _context7.next = 21;
                  break;
                }
                line = _step4.value;
                if (!done) {
                  _context7.next = 15;
                  break;
                }
                return _context7.abrupt("continue", 18);
              case 15:
                if (!line) {
                  _context7.next = 18;
                  break;
                }
                _context7.next = 18;
                return JSON.parse(line);
              case 18:
                _iteratorAbruptCompletion4 = false;
                _context7.next = 9;
                break;
              case 21:
                _context7.next = 27;
                break;
              case 23:
                _context7.prev = 23;
                _context7.t0 = _context7["catch"](7);
                _didIteratorError4 = true;
                _iteratorError4 = _context7.t0;
              case 27:
                _context7.prev = 27;
                _context7.prev = 28;
                if (!(_iteratorAbruptCompletion4 && _iterator5["return"] != null)) {
                  _context7.next = 32;
                  break;
                }
                _context7.next = 32;
                return _awaitAsyncGenerator(_iterator5["return"]());
              case 32:
                _context7.prev = 32;
                if (!_didIteratorError4) {
                  _context7.next = 35;
                  break;
                }
                throw _iteratorError4;
              case 35:
                return _context7.finish(32);
              case 36:
                return _context7.finish(27);
              case 37:
                done = true;
                _context7.next = 45;
                break;
              case 40:
                _context7.prev = 40;
                _context7.t1 = _context7["catch"](4);
                if (!(_context7.t1 instanceof Error && _context7.t1.name === 'AbortError')) {
                  _context7.next = 44;
                  break;
                }
                return _context7.abrupt("return");
              case 44:
                throw _context7.t1;
              case 45:
                _context7.prev = 45;
                // If the user `break`s, abort the ongoing request.
                if (!done) {
                  controller.abort();
                }
                return _context7.finish(45);
              case 48:
              case "end":
                return _context7.stop();
            }
          }, _callee7, null, [[4, 40, 45, 48], [7, 23, 27, 37], [28,, 32, 36]]);
        }));
        return _iterator6.apply(this, arguments);
      }
      return new Stream(iterator, controller);
    }
  }]);
  return Stream;
}(EventEmitter, Symbol.asyncIterator);
function partition(str, delimiter) {
  var index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, '', ''];
}

/**
 * 大多数浏览器尚未对 ReadableStream 提供异步可迭代支持，
 * 并且 Node.js 有一种非常不同的方式来从其 "ReadableStream" 中读取字节。
 *
 * 这个 polyfill 是从 https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490 拉取的。
 */
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator]) {
    return stream;
  }
  var reader = stream.getReader();
  return _defineProperty({
    next: function next() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var result;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _context8.next = 3;
              return reader.read();
            case 3:
              result = _context8.sent;
              if (result !== null && result !== void 0 && result.done) {
                reader.releaseLock();
              } // release lock when stream becomes closed
              return _context8.abrupt("return", result);
            case 8:
              _context8.prev = 8;
              _context8.t0 = _context8["catch"](0);
              reader.releaseLock(); // release lock when stream becomes errored
              throw _context8.t0;
            case 12:
            case "end":
              return _context8.stop();
          }
        }, _callee8, null, [[0, 8]]);
      }))();
    },
    "return": function _return() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var cancelPromise;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              cancelPromise = reader.cancel();
              reader.releaseLock();
              _context9.next = 4;
              return cancelPromise;
            case 4:
              return _context9.abrupt("return", {
                done: true,
                value: undefined
              });
            case 5:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }))();
    }
  }, Symbol.asyncIterator, function () {
    return this;
  });
}

createDebug('bce-sdk:HttpClient');
// 获取版本号
var version = version$3;
var HttpClient = /*#__PURE__*/function (_EventEmitter) {
  _inherits(HttpClient, _EventEmitter);
  function HttpClient(config, fetchConfig) {
    var _this;
    _classCallCheck(this, HttpClient);
    _this = _callSuper(this, HttpClient);
    _defineProperty(_assertThisInitialized(_this), "defaultHeaders", _defineProperty(_defineProperty(_defineProperty({}, CONTENT_TYPE, 'application/json; charset=UTF-8'), USER_AGENT, typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent : "bce-sdk-nodejs/".concat(version, "/").concat(process$1.platform, "/").concat(process$1.version)), X_BCE_DATE, new Date().toISOString().replace(/\.\d+Z$/, 'Z')));
    _this.config = config;
    _this.controller = new AbortController();
    _this.fetchInstance = new Fetch(fetchConfig);
    return _this;
  }

  /**
   * 获取签名
   *
   * @param config 请求配置对象
   * @returns 返回包含签名信息的 fetchOptions 对象
   */
  _createClass(HttpClient, [{
    key: "getSignature",
    value: (function () {
      var _getSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {
        var httpMethod, path, body, headers, params, signFunction, method, requestUrl, _headers, contentLength, url, options, reqHeaders, fetchOptions;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              httpMethod = config.httpMethod, path = config.path, body = config.body, headers = config.headers, params = config.params, signFunction = config.signFunction;
              method = httpMethod.toUpperCase();
              requestUrl = this._getRequestUrl(path, params);
              _headers = extend({}, this.defaultHeaders, headers);
              if (!_headers.hasOwnProperty(CONTENT_LENGTH)) {
                contentLength = this._guessContentLength(body);
                if (!(contentLength === 0 && /GET|HEAD/i.test(method))) {
                  // 如果是 GET 或 HEAD 请求，并且 Content-Length 是 0，那么 Request Header 里面就不要出现 Content-Length
                  // 否则本地计算签名的时候会计算进去，但是浏览器发请求的时候不一定会有，此时导致 Signature Mismatch 的情况
                  _headers[CONTENT_LENGTH] = contentLength;
                }
              }
              url = new URL$1(requestUrl);
              _headers[HOST] = url.host;
              options = urlObjectToPlainObject(url, method, _headers);
              _context.next = 10;
              return this.setAuthorizationHeader(signFunction, _headers, options);
            case 10:
              reqHeaders = _context.sent;
              fetchOptions = {
                url: options.href,
                method: options.method,
                headers: reqHeaders,
                body: body
              };
              return _context.abrupt("return", fetchOptions);
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getSignature(_x) {
        return _getSignature.apply(this, arguments);
      }
      return getSignature;
    }())
  }, {
    key: "sendRequest",
    value: function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(config) {
        var fetchOptions;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getSignature(config);
            case 2:
              fetchOptions = _context2.sent;
              return _context2.abrupt("return", this._doRequest(fetchOptions.url, fetchOptions, config.outputStream));
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function sendRequest(_x2) {
        return _sendRequest.apply(this, arguments);
      }
      return sendRequest;
    }()
  }, {
    key: "_doRequest",
    value: function () {
      var _doRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(url, fetchOptions, outputStream) {
        var resp, data;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!outputStream) {
                _context3.next = 2;
                break;
              }
              return _context3.abrupt("return", this.establishSSEConnection(url, fetchOptions));
            case 2:
              _context3.prev = 2;
              _context3.next = 5;
              return this.fetchInstance.fetchWithRetry(url, fetchOptions);
            case 5:
              resp = _context3.sent;
              _context3.next = 8;
              return resp.json();
            case 8:
              data = _context3.sent;
              return _context3.abrupt("return", data);
            case 12:
              _context3.prev = 12;
              _context3.t0 = _context3["catch"](2);
              throw new Error("Request failed: ".concat(_context3.t0.message));
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[2, 12]]);
      }));
      function _doRequest(_x3, _x4, _x5) {
        return _doRequest2.apply(this, arguments);
      }
      return _doRequest;
    }()
  }, {
    key: "establishSSEConnection",
    value: function () {
      var _establishSSEConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url, fetchOptions) {
        var response, contentType, res, message, sseStream;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return this.fetchInstance.fetchWithRetry(url, fetchOptions);
            case 3:
              response = _context4.sent;
              contentType = response.headers.get('Content-Type');
              if (!(contentType && contentType.includes('application/json'))) {
                _context4.next = 14;
                break;
              }
              _context4.next = 8;
              return response.json();
            case 8:
              res = _context4.sent;
              if (!res.error_code) {
                _context4.next = 12;
                break;
              }
              message = JSON.stringify(res);
              throw new Error(message);
            case 12:
              _context4.next = 16;
              break;
            case 14:
              sseStream = Stream.fromSSEResponse(response, this.controller);
              return _context4.abrupt("return", sseStream);
            case 16:
              _context4.next = 21;
              break;
            case 18:
              _context4.prev = 18;
              _context4.t0 = _context4["catch"](0);
              throw _context4.t0;
            case 21:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 18]]);
      }));
      function establishSSEConnection(_x6, _x7) {
        return _establishSSEConnection.apply(this, arguments);
      }
      return establishSSEConnection;
    }()
  }, {
    key: "setAuthorizationHeader",
    value: function () {
      var _setAuthorizationHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(signFunction, headers, options) {
        var result, _yield$result, _yield$result2, authorization, xbceDate;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(typeof signFunction === 'function')) {
                _context5.next = 20;
                break;
              }
              result = signFunction(this.config.credentials, options.method, options.path, headers);
              if (!(result instanceof Promise)) {
                _context5.next = 13;
                break;
              }
              _context5.next = 5;
              return result;
            case 5:
              _yield$result = _context5.sent;
              _yield$result2 = _slicedToArray(_yield$result, 2);
              authorization = _yield$result2[0];
              xbceDate = _yield$result2[1];
              headers[AUTHORIZATION] = authorization;
              if (xbceDate) {
                headers[X_BCE_DATE] = xbceDate;
              }
              _context5.next = 18;
              break;
            case 13:
              if (!(typeof result === 'string')) {
                _context5.next = 17;
                break;
              }
              headers[AUTHORIZATION] = result;
              _context5.next = 18;
              break;
            case 17:
              throw new Error("Invalid signature = (".concat(result, ")"));
            case 18:
              _context5.next = 21;
              break;
            case 20:
              headers[AUTHORIZATION] = this.createSignature(this.config.credentials, options.method, options.path, headers);
            case 21:
              return _context5.abrupt("return", headers);
            case 22:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function setAuthorizationHeader(_x8, _x9, _x10) {
        return _setAuthorizationHeader.apply(this, arguments);
      }
      return setAuthorizationHeader;
    }()
  }, {
    key: "_getRequestUrl",
    value: function _getRequestUrl(path, params) {
      var uri = path;
      var qs = this.buildQueryString(params);
      if (qs) {
        uri += '?' + qs;
      }
      if (/^https?/.test(uri)) {
        return uri;
      }
      return this.config.endpoint + uri;
    }
  }, {
    key: "buildQueryString",
    value: function buildQueryString(params) {
      var urlEncodeStr = require('querystring').stringify(params);

      // https://en.wikipedia.org/wiki/Percent-encoding
      return urlEncodeStr.replace(/[()'!~.*\-_]/g, function (_char) {
        return '%' + _char.charCodeAt(0).toString(16);
      });
    }

    /**
     * 猜测数据长度
     *
     * @param data 数据，可以是字符串、Buffer、可读流
     * @returns 返回数据长度
     * @throws {Error} 当没有指定 Content-Length 时抛出异常
     */
  }, {
    key: "_guessContentLength",
    value: function _guessContentLength(data) {
      if (data == null) {
        return 0;
      } else if (typeof data === 'string') {
        return Buffer.byteLength(data);
      } else if (_typeof(data) === 'object') {
        if (data instanceof Blob) {
          return data.size;
        }
        if (data instanceof ArrayBuffer) {
          return data.byteLength;
        }
        if (Buffer.isBuffer(data)) {
          return data.length;
        }
        if (_typeof(data) === 'object') {
          var keys = Object.keys(data);
          return keys.length;
        }
      } else if (Buffer.isBuffer(data)) {
        return data.length;
      }
      throw new Error('No Content-Length is specified.');
    }
  }, {
    key: "createSignature",
    value: function createSignature(credentials, httpMethod, path, headers) {
      var auth = new Auth(credentials.ak, credentials.sk);
      return auth.generateAuthorization(httpMethod, path, {}, headers);
    }
  }]);
  return HttpClient;
}(EventEmitter);

var BaseClient = /*#__PURE__*/function () {
  function BaseClient(options) {
    var _options$QIANFAN_AK,
      _options$QIANFAN_SK,
      _options$QIANFAN_ACCE,
      _options$QIANFAN_SECR,
      _options$QIANFAN_BASE,
      _options$QIANFAN_LLM_,
      _options$QIANFAN_LLM_2,
      _options$QIANFAN_LLM_3,
      _this = this;
    _classCallCheck(this, BaseClient);
    _defineProperty(this, "headers", DEFAULT_HEADERS);
    _defineProperty(this, "access_token", '');
    _defineProperty(this, "expires_in", 0);
    var defaultConfig = getDefaultConfig();
    this.qianfanAk = (_options$QIANFAN_AK = options === null || options === void 0 ? void 0 : options.QIANFAN_AK) !== null && _options$QIANFAN_AK !== void 0 ? _options$QIANFAN_AK : defaultConfig.QIANFAN_AK;
    this.qianfanSk = (_options$QIANFAN_SK = options === null || options === void 0 ? void 0 : options.QIANFAN_SK) !== null && _options$QIANFAN_SK !== void 0 ? _options$QIANFAN_SK : defaultConfig.QIANFAN_SK;
    this.qianfanAccessKey = (_options$QIANFAN_ACCE = options === null || options === void 0 ? void 0 : options.QIANFAN_ACCESS_KEY) !== null && _options$QIANFAN_ACCE !== void 0 ? _options$QIANFAN_ACCE : defaultConfig.QIANFAN_ACCESS_KEY;
    this.qianfanSecretKey = (_options$QIANFAN_SECR = options === null || options === void 0 ? void 0 : options.QIANFAN_SECRET_KEY) !== null && _options$QIANFAN_SECR !== void 0 ? _options$QIANFAN_SECR : defaultConfig.QIANFAN_SECRET_KEY;
    this.Endpoint = options === null || options === void 0 ? void 0 : options.Endpoint;
    this.qianfanBaseUrl = (_options$QIANFAN_BASE = options === null || options === void 0 ? void 0 : options.QIANFAN_BASE_URL) !== null && _options$QIANFAN_BASE !== void 0 ? _options$QIANFAN_BASE : defaultConfig.QIANFAN_BASE_URL;
    this.qianfanLlmApiRetryTimeout = (_options$QIANFAN_LLM_ = options === null || options === void 0 ? void 0 : options.QIANFAN_LLM_API_RETRY_TIMEOUT) !== null && _options$QIANFAN_LLM_ !== void 0 ? _options$QIANFAN_LLM_ : defaultConfig.QIANFAN_LLM_API_RETRY_TIMEOUT;
    this.qianfanLlmApiRetryBackoffFactor = (_options$QIANFAN_LLM_2 = options === null || options === void 0 ? void 0 : options.QIANFAN_LLM_API_RETRY_BACKOFF_FACTOR) !== null && _options$QIANFAN_LLM_2 !== void 0 ? _options$QIANFAN_LLM_2 : defaultConfig.QIANFAN_LLM_API_RETRY_BACKOFF_FACTOR;
    this.qianfanLlmApiRetryCount = (_options$QIANFAN_LLM_3 = options === null || options === void 0 ? void 0 : options.QIANFAN_LLM_API_RETRY_COUNT) !== null && _options$QIANFAN_LLM_3 !== void 0 ? _options$QIANFAN_LLM_3 : defaultConfig.QIANFAN_LLM_API_RETRY_COUNT;
    this.controller = new AbortController();
    this.fetchConfig = {
      retries: Number(this.qianfanLlmApiRetryCount),
      timeout: Number(this.qianfanLlmApiRetryTimeout),
      retryDelay: function retryDelay(attempt) {
        return calculateRetryDelay(attempt, Number(_this.qianfanLlmApiRetryBackoffFactor), Number(_this.qianfanLlmRetryMaxWaitInterval));
      }
    };
    this.fetchInstance = new Fetch(this.fetchConfig);
    this.tokenLimiter = new TokenLimiter();
  }

  /**
   * 使用 AK，SK 生成鉴权签名（Access Token）
   * @return string 鉴权签名信息（Access Token）
   */
  _createClass(BaseClient, [{
    key: "getAccessToken",
    value: (function () {
      var _getAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var url, _data$access_token, resp, data, error_msg;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              url = getAccessTokenUrl(this.qianfanAk, this.qianfanSk, this.qianfanBaseUrl);
              _context.prev = 1;
              _context.next = 4;
              return this.fetchInstance.fetchWithRetry(url, {
                headers: this.headers,
                method: 'POST'
              });
            case 4:
              resp = _context.sent;
              _context.next = 7;
              return resp.json();
            case 7:
              data = _context.sent;
              if (!(data !== null && data !== void 0 && data.error)) {
                _context.next = 10;
                break;
              }
              throw new Error((data === null || data === void 0 ? void 0 : data.error_description) || 'Failed to get access token');
            case 10:
              this.access_token = (_data$access_token = data.access_token) !== null && _data$access_token !== void 0 ? _data$access_token : '';
              this.expires_in = data.expires_in + Date.now() / 1000;
              return _context.abrupt("return", {
                access_token: data.access_token,
                expires_in: data.expires_in
              });
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](1);
              error_msg = "Failed to get access token: ".concat(_context.t0 && _context.t0.message);
              throw new Error(error_msg);
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 15]]);
      }));
      function getAccessToken() {
        return _getAccessToken.apply(this, arguments);
      }
      return getAccessToken;
    }())
  }, {
    key: "sendRequest",
    value: function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(IAMpath, AKPath, requestBody) {
        var _this2 = this;
        var stream,
          fetchOptions,
          config,
          client,
          url,
          tokens,
          hasToken,
          resp,
          val,
          usedTokens,
          sseStream,
          _sseStream$tee,
          _sseStream$tee2,
          stream1,
          stream2,
          updateTokensAsync,
          data,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              stream = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : false;
              if (!(!(this.qianfanAccessKey && this.qianfanSecretKey) && !(this.qianfanAk && this.qianfanSk))) {
                _context4.next = 3;
                break;
              }
              throw new Error('请设置AK/SK或QIANFAN_ACCESS_KEY/QIANFAN_SECRET_KEY');
            case 3:
              if (!(this.qianfanAccessKey && this.qianfanSecretKey)) {
                _context4.next = 9;
                break;
              }
              config = getIAMConfig(this.qianfanAccessKey, this.qianfanSecretKey, this.qianfanBaseUrl);
              client = new HttpClient(config);
              _context4.next = 8;
              return client.getSignature({
                httpMethod: 'POST',
                path: IAMpath,
                body: requestBody,
                headers: this.headers
              });
            case 8:
              fetchOptions = _context4.sent;
            case 9:
              if (!(this.qianfanAk && this.qianfanSk)) {
                _context4.next = 15;
                break;
              }
              if (!(this.expires_in < Date.now() / 1000)) {
                _context4.next = 13;
                break;
              }
              _context4.next = 13;
              return this.getAccessToken();
            case 13:
              url = "".concat(AKPath, "?access_token=").concat(this.access_token);
              fetchOptions = {
                url: url,
                method: 'POST',
                headers: this.headers,
                body: requestBody
              };
            case 15:
              // 计算请求token
              tokens = this.tokenLimiter.calculateTokens(requestBody);
              _context4.next = 18;
              return this.tokenLimiter.acquireTokens(tokens);
            case 18:
              hasToken = _context4.sent;
              if (!hasToken) {
                _context4.next = 43;
                break;
              }
              _context4.prev = 20;
              _context4.next = 23;
              return this.fetchInstance.fetchWithRetry(fetchOptions.url, fetchOptions);
            case 23:
              resp = _context4.sent;
              val = this.getTpmHeader(resp.headers);
              usedTokens = 0;
              if (!stream) {
                _context4.next = 31;
                break;
              }
              sseStream = Stream.fromSSEResponse(resp, this.controller);
              _sseStream$tee = sseStream.tee(), _sseStream$tee2 = _slicedToArray(_sseStream$tee, 2), stream1 = _sseStream$tee2[0], stream2 = _sseStream$tee2[1];
              if (isOpenTpm(val)) {
                updateTokensAsync = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _data, typedData, _typedData$usage;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          _iteratorAbruptCompletion = false;
                          _didIteratorError = false;
                          _context2.prev = 2;
                          _iterator = _asyncIterator(stream1);
                        case 4:
                          _context2.next = 6;
                          return _iterator.next();
                        case 6:
                          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                            _context2.next = 17;
                            break;
                          }
                          _data = _step.value;
                          typedData = _data;
                          if (!typedData.is_end) {
                            _context2.next = 14;
                            break;
                          }
                          usedTokens = typedData === null || typedData === void 0 || (_typedData$usage = typedData.usage) === null || _typedData$usage === void 0 ? void 0 : _typedData$usage.total_tokens;
                          _context2.next = 13;
                          return _this2.tokenLimiter.acquireTokens(usedTokens - tokens);
                        case 13:
                          return _context2.abrupt("break", 17);
                        case 14:
                          _iteratorAbruptCompletion = false;
                          _context2.next = 4;
                          break;
                        case 17:
                          _context2.next = 23;
                          break;
                        case 19:
                          _context2.prev = 19;
                          _context2.t0 = _context2["catch"](2);
                          _didIteratorError = true;
                          _iteratorError = _context2.t0;
                        case 23:
                          _context2.prev = 23;
                          _context2.prev = 24;
                          if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                            _context2.next = 28;
                            break;
                          }
                          _context2.next = 28;
                          return _iterator["return"]();
                        case 28:
                          _context2.prev = 28;
                          if (!_didIteratorError) {
                            _context2.next = 31;
                            break;
                          }
                          throw _iteratorError;
                        case 31:
                          return _context2.finish(28);
                        case 32:
                          return _context2.finish(23);
                        case 33:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2, null, [[2, 19, 23, 33], [24,, 28, 32]]);
                  }));
                  return function updateTokensAsync() {
                    return _ref.apply(this, arguments);
                  };
                }();
                setTimeout(updateTokensAsync, 0);
              }
              return _context4.abrupt("return", stream2);
            case 31:
              _context4.next = 33;
              return resp.json();
            case 33:
              data = _context4.sent;
              setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      usedTokens = _this2.getUsedTokens(data);
                      _context3.next = 3;
                      return _this2.tokenLimiter.acquireTokens(usedTokens - tokens);
                    case 3:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              })), 0);
              return _context4.abrupt("return", data);
            case 38:
              _context4.prev = 38;
              _context4.t0 = _context4["catch"](20);
              throw _context4.t0;
            case 41:
              _context4.next = 44;
              break;
            case 43:
              throw new Error('Token limit exceeded');
            case 44:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[20, 38]]);
      }));
      function sendRequest(_x, _x2, _x3) {
        return _sendRequest.apply(this, arguments);
      }
      return sendRequest;
    }()
  }, {
    key: "getTpmHeader",
    value: function getTpmHeader(headers) {
      var _headers$get;
      var val = (_headers$get = headers.get('x-ratelimit-limit-tokens')) !== null && _headers$get !== void 0 ? _headers$get : '0';
      this.tokenLimiter.resetTokens(val);
      return val;
    }
  }, {
    key: "getStreamUsedTokens",
    value: function () {
      var _getStreamUsedTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(data) {
        var _usedTokens;
        var usedTokens, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk, _chunk$usage;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              usedTokens = 0;
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context5.prev = 3;
              _iterator2 = _asyncIterator(data);
            case 5:
              _context5.next = 7;
              return _iterator2.next();
            case 7:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context5.sent).done)) {
                _context5.next = 13;
                break;
              }
              chunk = _step2.value;
              if (chunk.is_end) {
                usedTokens = chunk === null || chunk === void 0 || (_chunk$usage = chunk.usage) === null || _chunk$usage === void 0 ? void 0 : _chunk$usage.total_tokens;
              }
            case 10:
              _iteratorAbruptCompletion2 = false;
              _context5.next = 5;
              break;
            case 13:
              _context5.next = 19;
              break;
            case 15:
              _context5.prev = 15;
              _context5.t0 = _context5["catch"](3);
              _didIteratorError2 = true;
              _iteratorError2 = _context5.t0;
            case 19:
              _context5.prev = 19;
              _context5.prev = 20;
              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context5.next = 24;
                break;
              }
              _context5.next = 24;
              return _iterator2["return"]();
            case 24:
              _context5.prev = 24;
              if (!_didIteratorError2) {
                _context5.next = 27;
                break;
              }
              throw _iteratorError2;
            case 27:
              return _context5.finish(24);
            case 28:
              return _context5.finish(19);
            case 29:
              return _context5.abrupt("return", (_usedTokens = usedTokens) !== null && _usedTokens !== void 0 ? _usedTokens : 0);
            case 30:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[3, 15, 19, 29], [20,, 24, 28]]);
      }));
      function getStreamUsedTokens(_x4) {
        return _getStreamUsedTokens.apply(this, arguments);
      }
      return getStreamUsedTokens;
    }()
  }, {
    key: "getUsedTokens",
    value: function getUsedTokens(data) {
      var _data$usage;
      var usage = data === null || data === void 0 || (_data$usage = data.usage) === null || _data$usage === void 0 ? void 0 : _data$usage.total_tokens;
      return usage !== null && usage !== void 0 ? usage : 0;
    }
  }]);
  return BaseClient;
}();

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * 对话请求公共服务模型列表
 */

var modelInfoMap$4 = {
  'ERNIE-4.0-8K': {
    endpoint: '/chat/completions_pro',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-3.5-8K': {
    endpoint: '/chat/completions',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-3.5-8K-0205': {
    endpoint: '/chat/ERNIE-3.5-8K-0205',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-3.5-8K-1222': {
    endpoint: '/chat/ernie-3.5-8k-1222',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-3.5-4K-0205': {
    endpoint: '/chat/ernie-3.5-4k-0205',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE Speed-AppBuilder': {
    endpoint: '/chat/ai_apaas',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'Gemma-7B-it': {
    endpoint: '/chat/gemma_7b_it',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Bot-turbo': {
    endpoint: '/chat/eb-instant',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Speed-8K': {
    endpoint: '/chat/ernie_speed',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Speed-128K': {
    endpoint: '/chat/ernie-speed-128k',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Lite-8K-0922': {
    endpoint: '/chat/eb-instant',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Lite-8K-0308': {
    endpoint: '/chat/ernie-lite-8k',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'Mixtral-8x7B-Instruct': {
    endpoint: '/chat/mixtral_8x7b_instruct',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Bot': {
    endpoint: '/chat/completions',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'functions', 'system', 'user_id', 'user_setting', 'stop', 'disable_search', 'enable_citation', 'max_output_tokens', 'tool_choice']
  },
  'ERNIE-Bot-4': {
    endpoint: '/chat/completions_pro',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'functions', 'system', 'user_id', 'stop', 'disable_search', 'enable_citation', 'max_output_tokens']
  },
  'ERNIE-Bot-8k': {
    endpoint: '/chat/ernie_bot_8k',
    required_keys: ['messages'],
    optional_keys: ['functions', 'temperature', 'top_p', 'penalty_score', 'stream', 'system', 'stop', 'disable_search', 'enable_citation', 'user_id']
  },
  'ERNIE-Speed': {
    endpoint: '/chat/eb_turbo_pro',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Bot-turbo-AI': {
    endpoint: '/chat/ai_apaas',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'system', 'user_id', 'tools', 'tool_choice']
  },
  'EB-turbo-AppBuilder': {
    endpoint: '/chat/ai_apaas',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'system', 'user_id', 'tools', 'tool_choice']
  },
  'BLOOMZ-7B': {
    endpoint: '/chat/bloomz_7b1',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Llama-2-7b-chat': {
    endpoint: '/chat/llama_2_7b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Llama-2-13b-chat': {
    endpoint: '/chat/llama_2_13b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Llama-2-70b-chat': {
    endpoint: '/chat/llama_2_70b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Qianfan-BLOOMZ-7B-compressed': {
    endpoint: '/chat/qianfan_bloomz_7b_compressed',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Qianfan-Chinese-Llama-2-7B': {
    endpoint: '/chat/qianfan_chinese_llama_2_7b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'ChatGLM2-6B-32K': {
    endpoint: '/chat/chatglm2_6b_32k',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'AquilaChat-7B': {
    endpoint: '/chat/aquilachat_7b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'XuanYuan-70B-Chat-4bit': {
    endpoint: '/chat/xuanyuan_70b_chat',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Qianfan-Chinese-Llama-2-13B': {
    endpoint: '/chat/qianfan_chinese_llama_2_13b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'ChatLaw': {
    endpoint: '/chat/chatlaw',
    required_keys: ['messages', 'extra_parameters'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_p', 'tools', 'tool_choice']
  },
  'Yi-34B-Chat': {
    endpoint: '/chat/yi_34b_chat',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  UNSPECIFIED_MODEL: {
    endpoint: '',
    required_keys: ['messages'],
    optional_keys: []
  }
};

var ChatCompletion = /*#__PURE__*/function (_BaseClient) {
  _inherits(ChatCompletion, _BaseClient);
  function ChatCompletion() {
    _classCallCheck(this, ChatCompletion);
    return _callSuper(this, ChatCompletion, arguments);
  }
  _createClass(ChatCompletion, [{
    key: "chat",
    value: (
    /**
     * chat
     * @param body 聊天请求体
     * @param model 聊天模型，默认为 'ERNIE-Bot-turbo'
     * @param stream 是否开启流模式，默认为 false
     * @returns Promise<ChatResp | AsyncIterable<ChatResp>>
     */
    function () {
      var _chat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
        var _body$stream;
        var model,
          stream,
          _getUpperCaseModelAnd,
          modelInfoMapUppercase,
          modelUppercase,
          _getPathAndBody,
          IAMPath,
          AKPath,
          requestBody,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              model = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'ERNIE-Bot-turbo';
              stream = (_body$stream = body.stream) !== null && _body$stream !== void 0 ? _body$stream : false;
              _getUpperCaseModelAnd = getUpperCaseModelAndModelMap(model, modelInfoMap$4), modelInfoMapUppercase = _getUpperCaseModelAnd.modelInfoMapUppercase, modelUppercase = _getUpperCaseModelAnd.modelUppercase;
              _getPathAndBody = getPathAndBody({
                model: modelUppercase,
                modelInfoMap: modelInfoMapUppercase,
                baseUrl: this.qianfanBaseUrl,
                body: body,
                endpoint: this.Endpoint,
                type: 'chat'
              }), IAMPath = _getPathAndBody.IAMPath, AKPath = _getPathAndBody.AKPath, requestBody = _getPathAndBody.requestBody;
              return _context.abrupt("return", this.sendRequest(IAMPath, AKPath, requestBody, stream));
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function chat(_x) {
        return _chat.apply(this, arguments);
      }
      return chat;
    }())
  }]);
  return ChatCompletion;
}(BaseClient);

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * 续写公共服务模型列表
 */

var modelInfoMap$3 = {
  'ERNIE-Bot-turbo': {
    endpoint: '/chat/eb-instant',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'ERNIE-Bot': {
    endpoint: '/chat/completions',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'system', 'stop', 'disable_search', 'enable_citation', 'max_output_tokens']
  },
  'ERNIE-Bot-4': {
    endpoint: '/chat/completions_pro',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'system', 'stop', 'disable_search', 'enable_citation', 'max_output_tokens']
  },
  'ERNIE-Bot-8k': {
    endpoint: '/chat/ernie_bot_8k',
    required_keys: ['messages'],
    optional_keys: ['functions', 'temperature', 'top_p', 'penalty_score', 'stream', 'system', 'stop', 'disable_search', 'enable_citation', 'user_id']
  },
  'ERNIE-Speed': {
    endpoint: '/chat/eb_turbo_pro',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'user_id', 'tools', 'tool_choice', 'system']
  },
  'EB-turbo-AppBuilder': {
    endpoint: '/chat/ai_apaas',
    required_keys: ['messages'],
    optional_keys: ['stream', 'temperature', 'top_p', 'penalty_score', 'system', 'user_id', 'tools', 'tool_choice']
  },
  'BLOOMZ-7B': {
    endpoint: '/chat/bloomz_7b1',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Llama-2-7b-chat': {
    endpoint: '/chat/llama_2_7b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Llama-2-13b-chat': {
    endpoint: '/chat/llama_2_13b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Llama-2-70b-chat': {
    endpoint: '/chat/llama_2_70b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Qianfan-BLOOMZ-7B-compressed': {
    endpoint: '/chat/qianfan_bloomz_7b_compressed',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Qianfan-Chinese-Llama-2-7B': {
    endpoint: '/chat/qianfan_chinese_llama_2_7b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'ChatGLM2-6B-32K': {
    endpoint: '/chat/chatglm2_6b_32k',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'AquilaChat-7B': {
    endpoint: '/chat/aquilachat_7b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'XuanYuan-70B-Chat-4bit': {
    endpoint: '/chat/xuanyuan_70b_chat',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Qianfan-Chinese-Llama-2-13B': {
    endpoint: '/chat/qianfan_chinese_llama_2_13b',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'ChatLaw': {
    endpoint: '/chat/chatlaw',
    required_keys: ['messages', 'extra_parameters'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_p', 'tools', 'tool_choice']
  },
  'SQLCoder-7B': {
    endpoint: '/completions/sqlcoder_7b',
    required_keys: ['prompt'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'CodeLlama-7b-Instruct': {
    endpoint: '/completions/codellama_7b_instruct',
    required_keys: ['prompt'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  'Yi-34B-Chat': {
    endpoint: '/chat/yi_34b_chat',
    required_keys: ['messages'],
    optional_keys: ['stream', 'user_id', 'temperature', 'top_k', 'top_p', 'penalty_score', 'stop', 'tools', 'tool_choice']
  },
  UNSPECIFIED_MODEL: {
    endpoint: '',
    required_keys: ['prompt'],
    optional_keys: []
  }
};

// 检查是否为CompletionBody
function isCompletionBody(body) {
  return 'prompt' in body;
}

var _excluded = ["prompt"];
var Completions = /*#__PURE__*/function (_BaseClient) {
  _inherits(Completions, _BaseClient);
  function Completions() {
    _classCallCheck(this, Completions);
    return _callSuper(this, Completions, arguments);
  }
  _createClass(Completions, [{
    key: "completions",
    value: (
    /**
     * 续写
     * @param body 续写请求体
     * @param model 续写模型，默认为 'ERNIE-Bot-turbo'
     * @returns 返回 Promise 对象，异步获取续写结果
     */
    function () {
      var _completions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
        var _body$stream, _modelInfoMapUppercas;
        var model,
          stream,
          _getUpperCaseModelAnd,
          modelInfoMapUppercase,
          modelUppercase,
          required_keys,
          reqBody,
          prompt,
          restOfBody,
          _getPathAndBody,
          IAMPath,
          AKPath,
          requestBody,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              model = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'ERNIE-Bot-turbo';
              stream = (_body$stream = body.stream) !== null && _body$stream !== void 0 ? _body$stream : false;
              _getUpperCaseModelAnd = getUpperCaseModelAndModelMap(model, modelInfoMap$3), modelInfoMapUppercase = _getUpperCaseModelAnd.modelInfoMapUppercase, modelUppercase = _getUpperCaseModelAnd.modelUppercase; // 兼容Chat模型
              required_keys = (_modelInfoMapUppercas = modelInfoMapUppercase[modelUppercase]) === null || _modelInfoMapUppercas === void 0 ? void 0 : _modelInfoMapUppercas.required_keys;
              if (required_keys.includes('messages') && isCompletionBody(body)) {
                prompt = body.prompt, restOfBody = _objectWithoutProperties(body, _excluded);
                reqBody = _objectSpread2(_objectSpread2({}, restOfBody), {}, {
                  // 保留除prompt之外的所有属性
                  messages: [{
                    role: 'user',
                    content: prompt
                  }]
                });
              } else {
                reqBody = body;
              }
              _getPathAndBody = getPathAndBody({
                model: modelUppercase,
                modelInfoMap: modelInfoMapUppercase,
                baseUrl: this.qianfanBaseUrl,
                body: reqBody,
                endpoint: this.Endpoint,
                type: 'completions'
              }), IAMPath = _getPathAndBody.IAMPath, AKPath = _getPathAndBody.AKPath, requestBody = _getPathAndBody.requestBody;
              return _context.abrupt("return", this.sendRequest(IAMPath, AKPath, requestBody, stream));
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function completions(_x) {
        return _completions.apply(this, arguments);
      }
      return completions;
    }())
  }]);
  return Completions;
}(BaseClient);

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * 对话请求公共服务模型列表
 */

var modelInfoMap$2 = {
  'Embedding-V1': {
    endpoint: '/embeddings/embedding-v1',
    required_keys: ['input'],
    optional_keys: ['user_id']
  },
  'bge-large-en': {
    endpoint: '/embeddings/bge_large_en',
    required_keys: ['input'],
    optional_keys: ['user_id']
  },
  'bge-large-zh': {
    endpoint: '/embeddings/bge_large_zh',
    required_keys: ['input'],
    optional_keys: ['user_id']
  },
  'tao-8k': {
    endpoint: '/embeddings/tao_8k',
    required_keys: ['input'],
    optional_keys: ['user_id']
  },
  UNSPECIFIED_MODEL: {
    endpoint: '',
    required_keys: ['input'],
    optional_keys: []
  }
};

var Eembedding = /*#__PURE__*/function (_BaseClient) {
  _inherits(Eembedding, _BaseClient);
  function Eembedding() {
    _classCallCheck(this, Eembedding);
    return _callSuper(this, Eembedding, arguments);
  }
  _createClass(Eembedding, [{
    key: "embedding",
    value: (
    /**
     * 向量化
     * @param body 请求体
     * @param model 向量化模型，默认为'Embedding-V1'
     * @returns Promise<Resp | AsyncIterable<Resp>>
     */
    function () {
      var _embedding = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
        var model,
          _getUpperCaseModelAnd,
          modelInfoMapUppercase,
          modelUppercase,
          _getPathAndBody,
          IAMPath,
          AKPath,
          requestBody,
          resp,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              model = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'Embedding-V1';
              _getUpperCaseModelAnd = getUpperCaseModelAndModelMap(model, modelInfoMap$2), modelInfoMapUppercase = _getUpperCaseModelAnd.modelInfoMapUppercase, modelUppercase = _getUpperCaseModelAnd.modelUppercase;
              _getPathAndBody = getPathAndBody({
                model: modelUppercase,
                modelInfoMap: modelInfoMapUppercase,
                baseUrl: this.qianfanBaseUrl,
                body: body,
                endpoint: this.Endpoint,
                type: 'embeddings'
              }), IAMPath = _getPathAndBody.IAMPath, AKPath = _getPathAndBody.AKPath, requestBody = _getPathAndBody.requestBody;
              _context.next = 5;
              return this.sendRequest(IAMPath, AKPath, requestBody);
            case 5:
              resp = _context.sent;
              return _context.abrupt("return", resp);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function embedding(_x) {
        return _embedding.apply(this, arguments);
      }
      return embedding;
    }())
  }]);
  return Eembedding;
}(BaseClient);

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * 一言插件 v2
 */

var modelInfoMap$1 = {
  'EBPluginV2': {
    endpoint: '/erniebot/plugin',
    required_keys: ['messages', 'plugins'],
    optional_keys: ['user_id', 'extra_data']
  },
  UNSPECIFIED_MODEL: {
    endpoint: '',
    required_keys: ['query'],
    optional_keys: []
  }
};

var Plugin = /*#__PURE__*/function (_BaseClient) {
  _inherits(Plugin, _BaseClient);
  function Plugin() {
    _classCallCheck(this, Plugin);
    return _callSuper(this, Plugin, arguments);
  }
  _createClass(Plugin, [{
    key: "plugins",
    value: (
    /**
     * 插件
     * @param body 请求体
     * @param model 续写模型，默认为 'ERNIE-Bot-turbo'
     * @returns 返回 Promise 对象，异步获取续写结果
     */
    function () {
      var _plugins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
        var _body$stream;
        var model,
          stream,
          _getUpperCaseModelAnd,
          modelInfoMapUppercase,
          modelUppercase,
          _getPathAndBody,
          IAMPath,
          AKPath,
          requestBody,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              model = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'EBPluginV2';
              stream = (_body$stream = body.stream) !== null && _body$stream !== void 0 ? _body$stream : false;
              _getUpperCaseModelAnd = getUpperCaseModelAndModelMap(model, modelInfoMap$1), modelInfoMapUppercase = _getUpperCaseModelAnd.modelInfoMapUppercase, modelUppercase = _getUpperCaseModelAnd.modelUppercase;
              _getPathAndBody = getPathAndBody({
                model: modelUppercase,
                modelInfoMap: modelInfoMapUppercase,
                baseUrl: this.qianfanBaseUrl,
                body: body,
                endpoint: this.Endpoint,
                type: 'plugin'
              }), IAMPath = _getPathAndBody.IAMPath, AKPath = _getPathAndBody.AKPath, requestBody = _getPathAndBody.requestBody;
              _context.next = 6;
              return this.sendRequest(IAMPath, AKPath, requestBody, stream);
            case 6:
              return _context.abrupt("return", _context.sent);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function plugins(_x) {
        return _plugins.apply(this, arguments);
      }
      return plugins;
    }())
  }]);
  return Plugin;
}(BaseClient);

// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * 文生图模型
 */

var modelInfoMap = {
  'Stable-Diffusion-XL': {
    endpoint: '/text2image/sd_xl',
    required_keys: ['prompt'],
    optional_keys: ['negative_prompt', 'size', 'n', 'steps', 'sampler_index', 'user_id', 'seed', 'cfg_scale', 'style']
  },
  UNSPECIFIED_MODEL: {
    endpoint: '',
    required_keys: ['prompt'],
    optional_keys: []
  }
};

var Text2Image = /*#__PURE__*/function (_BaseClient) {
  _inherits(Text2Image, _BaseClient);
  function Text2Image() {
    _classCallCheck(this, Text2Image);
    return _callSuper(this, Text2Image, arguments);
  }
  _createClass(Text2Image, [{
    key: "text2Image",
    value: (
    /**
     * 文生图
     * @param body 续写请求体
     * @param model 续写模型，默认为 'ERNIE-Bot-turbo'
     * @returns 返回 Promise 对象，异步获取续写结果
     */
    function () {
      var _text2Image = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
        var model,
          _getUpperCaseModelAnd,
          modelInfoMapUppercase,
          modelUppercase,
          _getPathAndBody,
          IAMPath,
          AKPath,
          requestBody,
          resp,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              model = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'Stable-Diffusion-XL';
              _getUpperCaseModelAnd = getUpperCaseModelAndModelMap(model, modelInfoMap), modelInfoMapUppercase = _getUpperCaseModelAnd.modelInfoMapUppercase, modelUppercase = _getUpperCaseModelAnd.modelUppercase;
              _getPathAndBody = getPathAndBody({
                model: modelUppercase,
                modelInfoMap: modelInfoMapUppercase,
                baseUrl: this.qianfanBaseUrl,
                body: body,
                endpoint: this.Endpoint,
                type: 'text2image'
              }), IAMPath = _getPathAndBody.IAMPath, AKPath = _getPathAndBody.AKPath, requestBody = _getPathAndBody.requestBody;
              _context.next = 5;
              return this.sendRequest(IAMPath, AKPath, requestBody);
            case 5:
              resp = _context.sent;
              return _context.abrupt("return", resp);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function text2Image(_x) {
        return _text2Image.apply(this, arguments);
      }
      return text2Image;
    }())
  }]);
  return Text2Image;
}(BaseClient);

var Image2Text = /*#__PURE__*/function (_BaseClient) {
  _inherits(Image2Text, _BaseClient);
  function Image2Text() {
    _classCallCheck(this, Image2Text);
    return _callSuper(this, Image2Text, arguments);
  }
  _createClass(Image2Text, [{
    key: "image2Text",
    value: (
    /**
     * 图生文
     * @param body 请求体
     * @returns 返回文本转图像响应
     */
    function () {
      var _image2Text = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
        var _getPathAndBody, IAMPath, AKPath, requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _getPathAndBody = getPathAndBody({
                baseUrl: this.qianfanBaseUrl,
                body: body,
                endpoint: this.Endpoint,
                type: 'image2text'
              }), IAMPath = _getPathAndBody.IAMPath, AKPath = _getPathAndBody.AKPath, requestBody = _getPathAndBody.requestBody;
              _context.next = 3;
              return this.sendRequest(IAMPath, AKPath, requestBody);
            case 3:
              resp = _context.sent;
              return _context.abrupt("return", resp);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function image2Text(_x) {
        return _image2Text.apply(this, arguments);
      }
      return image2Text;
    }())
  }]);
  return Image2Text;
}(BaseClient);

export { ChatCompletion, Completions, Eembedding as Embedding, Image2Text, Plugin, Text2Image, setEnvVariable };
